<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>몬배틀 헌터즈 (MonBattle Hunters)</title>
    <!-- Tailwind CSS, Tone.js, Supabase, Three.js, GSAP -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* Base Styles */
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #2d2d2d; color: #cccccc; }
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .font-title { font-family: 'Black Han Sans', sans-serif; }

        /* Main Page Background Container */
        #pokedex-view-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 700px; 
            background-image: url('https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/public/main_bg_top.png?quality=80');
            background-size: cover;
            background-position: center top;
            background-repeat: no-repeat;
            z-index: -1;
            opacity: 0.5;
        }
        #pokedex-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #pokedex-view .max-w-7xl {
            position: relative;
            z-index: 1;
        }
        /* Mobile background fix */
        @media (max-width: 768px) {
            #pokedex-view-background {
                height: 60vh;
            }
        }


        /* Card Styles */
        .pokedex-card { background: #393939; border-left-width: 8px; transition: all 0.3s ease-in-out; cursor: pointer; position: relative; overflow: hidden; border-color: #515151; }
        .pokedex-card:hover { transform: translateY(-5px) scale(1.02); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .stat-bar-bg { background-color: #515151; border-radius: 999px; }
        .stat-bar { transition: width 0.8s ease-out; border-radius: 999px; }
        .rank-display { position: absolute; bottom: 8px; right: 8px; background-color: rgba(0,0,0,0.7); color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: bold; }
        .level-display {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #facc15; /* yellow-400 */
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 2;
        }

        /* Type & Universe Badges */
        .type-badge { padding: 4px 12px; border-radius: 12px; font-weight: 700; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .type-Normal { background-color: #A8A77A; } .type-Fire { background-color: #EE8130; }
        .type-Water { background-color: #6390F0; } .type-Electric { background-color: #F7D02C; }
        .type-Grass { background-color: #7AC74C; } .type-Ice { background-color: #96D9D6; }
        .type-Fighting { background-color: #C22E28; } .type-Poison { background-color: #A33EA1; }
        .type-Ground { background-color: #E2BF65; } .type-Flying { background-color: #A98FF3; }
        .type-Psychic { background-color: #F95587; } .type-Bug { background-color: #A6B91A; }
        .type-Rock { background-color: #B6A136; } .type-Ghost { background-color: #735797; }
        .type-Dragon { background-color: #6F35FC; } .type-Darkness { background-color: #705746; }
        .type-Steel { background-color: #B7B7CE; } .type-Fairy { background-color: #D685AD; }
        .type-Light { background: linear-gradient(45deg, #FFFDE4, #F9E79F); color: #B48A00; text-shadow: 0 0 2px white; }

        .universe-badge { font-size: 0.7rem; padding: 2px 8px; border-radius: 8px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .universe-감성의_숲 { background-color: #4CAF50; color: white; }
        .universe-악몽의_저택 { background-color: #4b0082; color: #e0e0e0; }
        .universe-사이버_펑크 { background: linear-gradient(45deg, #00BCD4, #F06292); color: white; }
        .universe-판타지_왕국 { background: linear-gradient(45deg, #FFD54F, #FF7043); color: white; }
        .universe-수정_동굴 { background: linear-gradient(45deg, #673AB7, #E040FB); color: white; }


        /* Rarity Styles */
        .rarity-badge { padding: 4px 12px; border-radius: 12px; font-weight: 900; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .rarity-일반 { background-color: #B0BEC5; } .rarity-희귀 { background-color: #42A5F5; }
        .rarity-에픽 { background-color: #AB47BC; } .rarity-전설 { background: linear-gradient(45deg, #FFEE58, #F57F17); text-shadow: 0 0 2px black; }
        .rarity-고대 { background: linear-gradient(45deg, #4DB6AC, #004D40); text-shadow: 0 0 2px black; }
        .rarity-신화 { background: linear-gradient(45deg, #FF7043, #D84315, #BF360C); text-shadow: 0 0 2px black; }
        
        .card-border-일반 { border-color: #B0BEC5; } .card-border-희귀 { border-color: #42A5F5; }
        .card-border-에픽 { border-color: #AB47BC; } .card-border-전설 { border-color: #F57F17; }
        .card-border-고대 { border-color: #004D40; } .card-border-신화 { border-color: #BF360C; }

        /* Special Rarity Card Effects */
        @keyframes glow-legendary { 0% { box-shadow: 0 0 5px #F57F17, 0 0 10px #F57F17, 0 0 15px #FFEE58; } 50% { box-shadow: 0 0 10px #FFEE58, 0 0 20px #FFEE58, 0 0 30px #F57F17; } 100% { box-shadow: 0 0 5px #F57F17, 0 0 10px #F57F17, 0 0 15px #FFEE58; } }
        .card-rarity-전설 { animation: glow-legendary 5s ease-in-out infinite; }
        @keyframes glow-ancient { 0% { box-shadow: 0 0 5px #4DB6AC, 0 0 10px #4DB6AC, 0 0 15px #004D40; } 50% { box-shadow: 0 0 10px #80CBC4, 0 0 20px #80CBC4, 0 0 30px #4DB6AC; } 100% { box-shadow: 0 0 5px #4DB6AC, 0 0 10px #4DB6AC, 0 0 15px #004D40; } }
        .card-rarity-고대 { animation: glow-ancient 4s ease-in-out infinite; }
        @keyframes glow-mythical { 0% { box-shadow: 0 0 5px #FF7043, 0 0 10px #FF7043, 0 0 15px #BF360C; } 50% { box-shadow: 0 0 10px #FFCC80, 0 0 20px #FFCC80, 0 0 30px #FF7043; } 100% { box-shadow: 0 0 5px #FF7043, 0 0 10px #FF7043, 0 0 15px #BF360C; } }
        .card-rarity-신화 { animation: glow-mythical 3s ease-in-out infinite; }
        @keyframes pulse-rare { 0%, 100% { box-shadow: 0 0 4px #42A5F5; } 50% { box-shadow: 0 0 12px #42A5F5; } }
        .card-rarity-희귀 { animation: pulse-rare 3s ease-in-out infinite; }

        /* Shimmer Effect for High-Rarity Cards */
        .shimmer-effect::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(110deg, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0) 60%);
            transform: rotate(30deg);
            animation: shimmer 5s infinite;
            pointer-events: none;
        }
        @keyframes shimmer {
            0% { transform: translate(-100%, -100%) rotate(30deg); }
            100% { transform: translate(100%, 100%) rotate(30deg); }
        }
        
        .rank-1 { box-shadow: 0 0 15px gold, 0 0 5px gold inset; border-color: gold; }
        .rank-2 { box-shadow: 0 0 15px silver, 0 0 5px silver inset; border-color: silver; }
        .rank-3 { box-shadow: 0 0 15px #CD7F32, 0 0 5px #CD7F32 inset; border-color: #CD7F32; }

        /* Status & Rarity Icons */
        .icon-container { position: absolute; top: 10px; right: 10px; display: flex; gap: 4px; z-index: 3; }
        .status-icon, .rarity-star-icon { width: 24px; height: 24px; }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 0.7; } }
        .status-icon svg { animation: pulse 2s infinite; filter: drop-shadow(0 0 3px rgba(171, 71, 188, 0.8)); }
        .rarity-star-icon svg { filter: drop-shadow(0 0 3px rgba(255, 215, 0, 0.8)); }

        /* Battle Arena Styles */
        #battle-arena-view { position: relative; overflow: hidden; min-height: 100vh; }
        #battle-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .battle-ui-overlay { position: relative; z-index: 2; pointer-events: none; }
        .battle-ui-overlay > * { pointer-events: all; }
        @keyframes screen-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .screen-shake { animation: screen-shake 0.3s; }

        .hp-bar-inner { transition: width 0.5s ease-in-out; }
        #battle-log { height: 150px; backdrop-filter: blur(5px); }
        .log-damage { color: #ffdddd; } .log-crit { color: #fffa65; font-weight: bold; }
        .log-super-effective { color: #a3ffb4; font-weight: bold; }
        .log-not-effective { color: #d1d1d1; } .log-no-effect { color: #999999; }
        .log-turn { color: #82ccdd; } .log-win { color: #f7b731; font-size: 1.25rem; font-weight: bold; text-shadow: 0 0 5px black; }
        .log-rank { color: #eab308; font-style: italic; }
        .log-status-poison { color: #ce93d8; font-style: italic; }
        .log-status-paralysis { color: #fff176; font-style: italic; }
        .log-status-sleep { color: #90a4ae; font-style: italic; }
        .log-heal { color: #a3ffb4; font-style: italic; }
        .log-buff { color: #81d4fa; font-style: italic; }
        .log-debuff { color: #ffab91; font-style: italic; }
        .log-shield { color: #b3e5fc; font-style: italic; }
        .log-ability { color: #f48fb1; font-weight: bold; text-shadow: 0 0 3px black; }
        .log-desperate { color: #ff8a80; font-weight: bold; text-shadow: 0 0 5px black; }
        
        #battle-effects-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5000; }
        .impact-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Black Han Sans', sans-serif; text-shadow: 3px 3px 5px rgba(0,0,0,0.5); animation: impact-pop 1s ease-out forwards; }
        .impact-text.crit { color: #fffa65; }
        .impact-text.super-effective { color: #a3ffb4; }
        @keyframes impact-pop { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 80% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
        
        .damage-number {
            position: absolute;
            font-size: 2rem;
            font-weight: bold;
            font-family: 'Black Han Sans', sans-serif;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.7);
            pointer-events: none;
            color: white;
        }
        .damage-number.crit {
            color: #fffa65;
            font-size: 2.5rem;
        }

        .battle-moves-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
        .battle-move-item { background-color: rgba(0,0,0,0.5); padding: 4px; border-radius: 4px; font-size: 0.7rem; text-align: center; transition: all 0.2s ease; cursor: pointer; }
        .battle-move-item:hover { background-color: rgba(255,255,255,0.1); }
        @keyframes skill-use-glow { 0%, 100% { transform: scale(1); box-shadow: 0 0 0px #fff; } 50% { transform: scale(1.1); box-shadow: 0 0 15px #fff; } }
        .skill-use-animation { animation: skill-use-glow 0.5s ease-in-out; }

        /* General UI Components */
        .filter-btn { padding: 8px 16px; border-radius: 8px; font-weight: bold; transition: all 0.2s; }
        .filter-btn.active { background-color: #8abeb7; color: white; }
        .filter-btn:not(.active) { background-color: #515151; color: #cccccc; }

        /* Modal Styles */
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; animation: fadeIn 0.3s; }
        .modal-content { background: #393939; color: #cccccc; padding: 1.5rem; border-radius: 1rem; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .type-chart-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 0.5rem; }
        .type-chart-cell { text-align: center; padding: 0.5rem; border-radius: 0.5rem; }

        /* Ranking Podium */
        .podium { display: flex; justify-content: center; align-items: flex-end; gap: 1rem; min-height: 250px; }
        .podium-item { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .podium-2 { order: 1; }
        .podium-1 { order: 2; }
        .podium-3 { order: 3; }
        .podium-img { border-radius: 50%; object-fit: cover; border: 4px solid; cursor: pointer; }
        .podium-1 .podium-img { width: 120px; height: 120px; border-color: #FFD700; }
        .podium-2 .podium-img { width: 100px; height: 100px; border-color: #C0C0C0; }
        .podium-3 .podium-img { width: 80px; height: 80px; border-color: #CD7F32; }
        .podium-base { color: white; font-weight: bold; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; }
        .podium-1 .podium-base { background-color: #FFD700; width: 100%; min-height: 100px; }
        .podium-2 .podium-base { background-color: #C0C0C0; width: 100%; min-height: 75px; }
        .podium-3 .podium-base { background-color: #CD7F32; width: 100%; min-height: 50px; }
        
        /* Rank Badge Styles */
        .rank-badge { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0.75rem; border-radius: 999px; font-weight: bold; border: 2px solid; }
        .badge-gold { background: linear-gradient(45deg, #FFD700, #FBB034); color: #4A2E00; border-color: #FEE101; box-shadow: 0 0 10px #FBB034; }
        .badge-silver { background: linear-gradient(45deg, #E0E0E0, #BDBDBD); color: #333; border-color: #F5F5F5; box-shadow: 0 0 10px #BDBDBD; }
        .badge-bronze { background: linear-gradient(45deg, #CD7F32, #A0522D); color: white; border-color: #D2691E; box-shadow: 0 0 10px #A0522D; }
        .badge-iron { background-color: #757575; color: white; border-color: #9E9E9E; }
        .badge-stone { background-color: #B0BEC5; color: #263238; border-color: #CFD8DC; }
        .badge-wood { background-color: #8D6E63; color: white; border-color: #A1887F; }
    </style>
</head>
<body class="bg-[#2d2d2d] text-gray-300">
    <!-- Overlays and Loaders -->
    <div id="skill-effect-overlay"></div>
    <div id="modal-container"></div>
    <div id="battle-effects-container"></div>

    <!-- Navigation Bar -->
    <nav class="bg-gray-900 shadow-lg sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <span class="font-title text-2xl text-[#9c9] cursor-pointer" id="home-btn">몬배틀 헌터즈</span>
                </div>
                <div id="nav-links" class="flex items-center gap-2 sm:gap-4"></div>
            </div>
        </div>
    </nav>

    <!-- Auth View -->
    <div id="auth-view" class="view">
        <div class="max-w-md mx-auto mt-10 p-8 bg-gray-800 rounded-lg shadow-lg">
            <div id="auth-tabs" class="flex border-b border-gray-700 mb-6">
                <button data-tab="login" class="tab-btn flex-1 py-2 font-bold text-gray-500 border-b-2 border-transparent">로그인</button>
                <button data-tab="signup" class="tab-btn flex-1 py-2 font-bold text-gray-500 border-b-2 border-transparent">회원가입</button>
            </div>
            <!-- Login Form -->
            <form id="login-form" class="auth-form space-y-4">
                <input type="email" id="login-email" placeholder="이메일" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <input type="password" id="login-password" placeholder="비밀번호" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <button type="submit" class="w-full bg-[#8abeb7] text-white font-bold py-3 rounded-lg hover:bg-[#6cc]">로그인</button>
            </form>
            <!-- Signup Form -->
            <form id="signup-form" class="auth-form space-y-4 hidden">
                <input type="email" id="signup-email" placeholder="이메일" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <input type="password" id="signup-password" placeholder="비밀번호" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <button type="submit" class="w-full bg-[#9c9] text-white font-bold py-3 rounded-lg hover:bg-[#7a7]">회원가입 (5 크레딧 지급)</button>
            </form>
            <p id="auth-error" class="text-red-400 text-center mt-4"></p>
        </div>
    </div>

    <!-- Main Pokedex View -->
    <div id="pokedex-view" class="view">
        <div id="pokedex-view-background">
             <canvas id="pokedex-bg-canvas"></canvas>
        </div>
        <div class="max-w-7xl mx-auto p-4 sm:p-6 md:p-8">
            <header class="text-center mb-8">
                <h1 class="font-title text-5xl md:text-6xl text-gray-100">몬배틀 헌터즈</h1>
                <p class="text-gray-400 mt-2">키우고, 합치고, 싸워라! 이것이 진짜 몬배틀.</p>
                 <div class="mt-4 flex justify-center flex-wrap gap-2 sm:gap-4">
                      <button id="go-to-battle-btn" class="bg-[#c99] text-white font-bold py-2 px-4 rounded-lg hover:bg-[#a77] transition-transform transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed">배틀 아레나</button>
                      <button id="go-to-ranking-btn" class="bg-[#f99157] text-white font-bold py-2 px-4 rounded-lg hover:bg-[#d76e2d] transition-transform transform hover:scale-105">랭킹 보기</button>
                      <button id="show-type-chart-btn" class="bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg hover:bg-[#6cc] transition-transform transform hover:scale-105">상성표</button>
                      <button id="show-rarity-table-btn" class="bg-[#c9c] text-white font-bold py-2 px-4 rounded-lg hover:bg-[#a7a] transition-transform transform hover:scale-105">등급표</button>
                 </div>
            </header>

            <!-- Ranking Podium -->
            <div id="ranking-podium-container" class="mb-12">
                <h2 class="font-title text-3xl text-center mb-4 text-gray-200">명예의 전당</h2>
                <div id="ranking-podium-view" class="podium"></div>
            </div>

            <div id="character-creation-section" class="bg-gray-800/80 backdrop-blur-sm p-6 rounded-2xl shadow-lg mb-8">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <select id="universe-select" class="p-3 border-2 rounded-lg focus:outline-none focus:ring-2 bg-gray-700 text-white border-gray-600 focus:ring-[#9c9]">
                        <option value="감성의_숲">감성의 숲</option>
                        <option value="악몽의_저택">악몽의 저택</option>
                        <option value="사이버_펑크">사이버 펑크</option>
                        <option value="판타지_왕국">판타지 왕국</option>
                        <option value="수정_동굴">수정 동굴</option>
                    </select>
                    <input type="text" id="character-prompt" class="md:col-span-2 p-3 border-2 rounded-lg focus:outline-none focus:ring-2 bg-gray-700 text-white border-gray-600 focus:ring-[#8abeb7]" placeholder="예: 거미 다리를 가진 피카츄, 얼굴은 슈퍼마리오">
                </div>
                <div class="mt-4 flex justify-center items-center gap-4">
                    <button id="generate-btn" class="bg-[#8abeb7] text-white font-bold py-3 px-6 rounded-lg hover:bg-[#6cc] transition-transform transform hover:scale-105">
                        <span id="btn-text">크리처 소환! (1 크레딧)</span>
                    </button>
                </div>
                <div id="error-message" class="text-yellow-400 mt-4 text-center text-sm font-semibold"></div>
            </div>
             <div id="filter-container" class="flex justify-center gap-2 mb-6">
                  <button class="filter-btn active" data-filter="all">전체</button>
                  <button class="filter-btn" data-filter="감성의_숲">감성의 숲</button>
                  <button class="filter-btn" data-filter="악몽의_저택">악몽의 저택</button>
                  <button class="filter-btn" data-filter="사이버_펑크">사이버 펑크</button>
                  <button class="filter-btn" data-filter="판타지_왕국">판타지 왕국</button>
                  <button class="filter-btn" data-filter="수정_동굴">수정 동굴</button>
             </div>
            <div id="pokedex-container" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6"></div>
            <div id="empty-state" class="text-center py-16 px-6 bg-gray-800 rounded-2xl shadow-lg hidden"><h3 class="mt-4 text-xl font-semibold text-gray-100">도감이 비어있습니다. 첫 크리처를 소환해보세요!</h3></div>
            <div id="pagination-controls" class="text-center mt-8"></div>
        </div>
    </div>
    
    <!-- Other Views (Containers) -->
    <div id="detail-view" class="view"></div>
    <div id="battle-selection-view" class="view"></div>
    <div id="battle-arena-view" class="view"></div>
    <div id="ranking-view" class="view"></div>
    <div id="profile-view" class="view"></div>
    <div id="admin-view" class="view"></div>

    <script type="module">
        /*
            --- SUPABASE SETUP FOR BATTLE RECORDS ---
            
            1. Create the 'battle_records' table in your Supabase SQL Editor:

            CREATE TABLE public.battle_records (
                character_id bigint NOT NULL,
                wins integer DEFAULT 0 NOT NULL,
                losses integer DEFAULT 0 NOT NULL,
                CONSTRAINT battle_records_pkey PRIMARY KEY (character_id),
                CONSTRAINT battle_records_character_id_fkey FOREIGN KEY (character_id) REFERENCES public.battle_characters(id) ON DELETE CASCADE
            );
            ALTER TABLE public.battle_records ENABLE ROW LEVEL SECURITY;
            CREATE POLICY "Public records are viewable by everyone." ON public.battle_records FOR SELECT USING (true);
            CREATE POLICY "Users can update their own character records." ON public.battle_records FOR UPDATE USING (auth.uid() = ( SELECT creator_id FROM public.battle_characters WHERE id = character_id ));


            2. Create the 'update_battle_record' RPC function in your Supabase SQL Editor:

            CREATE OR REPLACE FUNCTION public.update_battle_record(
                char_id bigint,
                is_win boolean
            )
            RETURNS void
            LANGUAGE plpgsql
            SECURITY DEFINER -- Important!
            AS $$
            BEGIN
                IF is_win THEN
                    INSERT INTO public.battle_records (character_id, wins, losses)
                    VALUES (char_id, 1, 0)
                    ON CONFLICT (character_id)
                    DO UPDATE SET wins = battle_records.wins + 1;
                ELSE
                    INSERT INTO public.battle_records (character_id, wins, losses)
                    VALUES (char_id, 0, 1)
                    ON CONFLICT (character_id)
                    DO UPDATE SET losses = battle_records.losses + 1;
                END IF;
            END;
            $$;

            3. Create the 'get_character_rank' RPC function for detailed ranking display:

            CREATE OR REPLACE FUNCTION public.get_character_rank(char_id bigint)
            RETURNS integer
            LANGUAGE sql
            AS $$
              SELECT rank
              FROM (
                SELECT id, RANK() OVER (ORDER BY rank_points DESC) as rank
                FROM public.battle_characters
              ) as ranked_characters
              WHERE id = char_id;
            $$;
        */

        // --- Supabase Client Setup ---
        const { createClient } = supabase;
        const SUPABASE_URL = 'https://yqnyinreoamegbahoxzq.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlxbnlpbnJlb2FtZWdiYWhveHpxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxMzgxNjMsImV4cCI6MjA3MDcxNDE2M30.GjzEs-MNYlk1JUncO_A4wimYdD6JXfiqKZvI1ugR47o';
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- DOM Elements ---
        const views = document.querySelectorAll('.view');
        const modalContainer = document.getElementById('modal-container');
        const navLinks = document.getElementById('nav-links');
        const homeBtn = document.getElementById('home-btn');
        const authView = document.getElementById('auth-view');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const authError = document.getElementById('auth-error');
        const generateBtn = document.getElementById('generate-btn');
        const universeSelect = document.getElementById('universe-select');
        const promptInput = document.getElementById('character-prompt');
        const pokedexContainer = document.getElementById('pokedex-container');
        const emptyState = document.getElementById('empty-state');
        const errorMessage = document.getElementById('error-message');
        const btnText = document.getElementById('btn-text');
        const goToBattleBtn = document.getElementById('go-to-battle-btn');
        const goToRankingBtn = document.getElementById('go-to-ranking-btn');
        const showTypeChartBtn = document.getElementById('show-type-chart-btn');
        const showRarityTableBtn = document.getElementById('show-rarity-table-btn');
        const characterCreationSection = document.getElementById('character-creation-section');
        const detailViewContainer = document.getElementById('detail-view');
        const battleSelectionViewContainer = document.getElementById('battle-selection-view');
        const battleArenaContainer = document.getElementById('battle-arena-view');
        const rankingViewContainer = document.getElementById('ranking-view');
        const profileViewContainer = document.getElementById('profile-view');
        const adminViewContainer = document.getElementById('admin-view');
        const skillEffectOverlay = document.getElementById('skill-effect-overlay');
        const rankingPodiumView = document.getElementById('ranking-podium-view');
        const filterBtns = document.querySelectorAll('.filter-btn');
        const battleEffectsContainer = document.getElementById('battle-effects-container');
        const paginationControls = document.getElementById('pagination-controls');

        // --- App State & Data (Local Cache) ---
        let currentUser = null;
        let currentProfile = null;
        let allCharacters = []; // This will now hold only the currently loaded characters
        let totalCharacterCount = 0;
        let currentPage = 0;
        const PAGE_SIZE = 12;
        let isLoadingMore = false;
        let allProfiles = [];
        let characterSubscription = null;
        let activeFilter = 'all';
        let pokedexAnimationId = null; 
        let battleAnimationId = null; 

        const battleBackgrounds = [
            'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/producerbp-1-2022-10-24.jpg',
            'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/producerbp-1-2021-02-16.jpg',
            'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/producerbp-1-2020-06-10.jpg',
            'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/producerbp-1-2019-07-26.jpg',
            'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/producerbp-1-2019-03-13.jpg',
            'https://yqnyinreoamegbahoxzq.supabase.co/storage/v1/object/public/battle_images/2021-pokemon-battle-pokemon-unite-online-video-game-wallpaper-2560x1600-74929_7.jpg'
        ];
        const typeChart = { Normal: { Rock: 0.5, Ghost: 0, Steel: 0.5 }, Fire: { Fire: 0.5, Water: 0.5, Grass: 2, Ice: 2, Bug: 2, Rock: 0.5, Dragon: 0.5, Steel: 2 }, Water: { Fire: 2, Water: 0.5, Grass: 0.5, Ground: 2, Rock: 2, Dragon: 0.5 }, Electric: { Water: 2, Electric: 0.5, Grass: 0.5, Ground: 0, Flying: 2, Dragon: 0.5 }, Grass: { Fire: 0.5, Water: 2, Grass: 0.5, Poison: 0.5, Ground: 2, Flying: 0.5, Bug: 0.5, Rock: 2, Dragon: 0.5, Steel: 0.5 }, Ice: { Fire: 0.5, Water: 0.5, Grass: 2, Ice: 0.5, Ground: 2, Flying: 2, Dragon: 2, Steel: 0.5 }, Fighting: { Normal: 2, Ice: 2, Poison: 0.5, Flying: 0.5, Psychic: 0.5, Bug: 0.5, Rock: 2, Ghost: 0, Darkness: 2, Steel: 2, Fairy: 0.5 }, Poison: { Grass: 2, Poison: 0.5, Ground: 0.5, Rock: 0.5, Ghost: 0.5, Steel: 0, Fairy: 2 }, Ground: { Fire: 2, Electric: 2, Grass: 0.5, Poison: 2, Flying: 0, Bug: 0.5, Rock: 2, Steel: 2 }, Flying: { Electric: 0.5, Grass: 2, Fighting: 2, Bug: 2, Rock: 0.5, Steel: 0.5 }, Psychic: { Fighting: 2, Poison: 2, Psychic: 0.5, Darkness: 2, Steel: 0.5 }, Bug: { Fire: 0.5, Grass: 2, Fighting: 0.5, Poison: 0.5, Flying: 0.5, Psychic: 2, Ghost: 0.5, Darkness: 2, Steel: 0.5, Fairy: 0.5 }, Rock: { Fire: 2, Ice: 2, Fighting: 0.5, Ground: 0.5, Flying: 2, Bug: 2, Steel: 0.5 }, Ghost: { Normal: 0, Psychic: 2, Ghost: 2, Darkness: 0.5, Light: 2 }, Dragon: { Dragon: 2, Steel: 0.5, Fairy: 0 }, Steel: { Fire: 0.5, Water: 0.5, Electric: 0.5, Ice: 2, Rock: 2, Steel: 0.5, Fairy: 2, Light: 0.5 }, Fairy: { Fighting: 2, Poison: 0.5, Dragon: 2, Darkness: 2, Steel: 0.5 }, Light: { Ghost: 2, Darkness: 2, Grass: 0.5, Steel: 0.5, Fire: 0.5 }, Darkness: { Psychic: 2, Ghost: 2, Light: 2, Fighting: 0.5, Fairy: 0.5 } };
        const typeTranslations = { Normal: '노말', Fire: '불꽃', Water: '물', Electric: '전기', Grass: '풀', Ice: '얼음', Fighting: '격투', Poison: '독', Ground: '땅', Flying: '비행', Psychic: '에스퍼', Bug: '벌레', Rock: '바위', Ghost: '고스트', Dragon: '드래곤', Darkness: '악', Steel: '강철', Fairy: '페어리', Light: '빛' };
        
        // --- [EXPANDED & BALANCED] Master Skill List ---
        const MASTER_SKILL_LIST = {
            // Damage
            'DMG_PHY_S': { type: 'damage', category: 'Physical', power: 40, text: '기본 물리 공격' },
            'DMG_SPE_S': { type: 'damage', category: 'Special', power: 40, text: '기본 특수 공격' },
            'DMG_PHY_M': { type: 'damage', category: 'Physical', power: 80, text: '강한 물리 공격' },
            'DMG_SPE_M': { type: 'damage', category: 'Special', power: 80, text: '강한 특수 공격' },
            'DMG_PHY_L': { type: 'damage', category: 'Physical', power: 120, text: '매우 강한 물리 공격' },
            'DMG_SPE_L': { type: 'damage', category: 'Special', power: 120, text: '매우 강한 특수 공격' },
            // High-Risk High-Reward
            'DMG_PHY_XL_RECOIL': { type: 'damage', category: 'Physical', power: 150, recoil: 0.33, text: '초강력 물리 공격, 준 데미지의 33%를 반동 데미지로 받음' },
            'DMG_SPE_DEBUFF_SELF': { type: 'damage', category: 'Special', power: 140, selfDebuff: { stat: 'sp_atk', amount: -2, turns: 99 }, text: '초강력 특수 공격, 사용 후 자신의 특공이 영구히 하락' },
            // Priority
            'DMG_PHY_PRIORITY': { type: 'damage', category: 'Physical', power: 40, priority: 1, text: '위력은 낮지만 반드시 선제공격' },
            // Conditional
            'DMG_SPE_CONDITIONAL_STATUS': { type: 'damage', category: 'Special', power: 70, conditional: 'status', multiplier: 2, text: '상대가 상태 이상일 때 위력 2배' },
            'DMG_PHY_LOW_HP_BOOST': { type: 'damage', category: 'Physical', power: 60, conditional: 'low_hp', text: '자신의 HP가 1/3 이하일 때 위력 2.5배' },
            // Healing (NERFED)
            'HEAL_S': { type: 'heal', power: 0.25, text: '자신 최대 HP의 25% 회복' },
            'HEAL_M': { type: 'heal', power: 0.50, text: '자신 최대 HP의 50% 회복' },
            // Buffs (Self)
            'BUFF_ATK_S': { type: 'buff', stat: 'attack', amount: 1, turns: 3, text: '자신 공격 상승 (3턴)' },
            'BUFF_DEF_S': { type: 'buff', stat: 'defense', amount: 1, turns: 3, text: '자신 방어 상승 (3턴)' },
            'BUFF_SPD_S': { type: 'buff', stat: 'speed', amount: 1, turns: 3, text: '자신 속도 상승 (3턴)' },
            'BUFF_ALL_S': { type: 'buff', stat: 'all', amount: 1, turns: 2, text: '자신 모든 능력치 상승 (2턴)' },
            // Debuffs (Opponent)
            'DEBUFF_ATK_S': { type: 'debuff', stat: 'attack', amount: -1, turns: 3, text: '상대 공격 하락 (3턴)' },
            'DEBUFF_DEF_S': { type: 'debuff', stat: 'defense', amount: -1, turns: 3, text: '상대 방어 하락 (3턴)' },
            'DEBUFF_SPD_S': { type: 'debuff', stat: 'speed', amount: -1, turns: 3, text: '상대 속도 하락 (3턴)' },
            // Status Effects
            'STATUS_POISON': { type: 'status', effect: 'poison', chance: 0.3, text: '30% 확률로 상대를 중독 상태로 만듦' },
            'STATUS_PARALYSIS': { type: 'status', effect: 'paralysis', chance: 0.3, text: '30% 확률로 상대를 마비 상태로 만듦' },
            'STATUS_SLEEP': { type: 'status', effect: 'sleep', chance: 0.3, text: '30% 확률로 상대를 수면 상태로 만듦' },
            // Damage over Time (DoT)
            'DOT_POISON_S': { type: 'dot', effect: 'poison', damage: 0.0625, turns: 4, text: '4턴간 매 턴 상대 최대 HP의 1/16 독 데미지' },
            // Shield
            'SHIELD_S': { type: 'shield', amount: 0.25, text: '자신 최대 HP의 25%만큼 보호막 생성' },
        };
        
        // --- [NEW] Master Ability List ---
        const MASTER_ABILITY_LIST = {
            'INTIMIDATE': { text: '등장 시 상대의 공격을 1단계 하락시킨다.' },
            'SPEED_BOOST': { text: '매 턴이 끝날 때마다 자신의 속도가 1단계 상승한다.' },
            'REGENERATOR': { text: '매 턴이 끝날 때마다 최대 체력의 1/16을 회복한다.' },
            'GUTS': { text: '상태 이상에 걸리면 공격이 1.5배 상승한다.' },
            'TECHNICIAN': { text: '위력 60 이하 기술의 위력이 1.5배가 된다.' },
        };

        // --- Sound Engine ---
        let synths = {};
        function setupAudio() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (!synths.hit) {
                synths.hit = new Tone.MembraneSynth().toDestination();
                synths.crit = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
                synths.superEffective = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination();
                synths.victory = new Tone.PolySynth(Tone.Synth).toDestination();
                synths.defeat = new Tone.PolySynth(Tone.FMSynth).toDestination();
                synths.uiClick = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            }
        }
        const playHitSound = () => synths.hit?.triggerAttackRelease("C2", "8n");
        const playCritSound = () => synths.crit?.triggerAttackRelease("C5", "16n");
        const playSuperEffectiveSound = () => synths.superEffective?.triggerAttackRelease("G5", "16n");
        const playVictorySound = () => synths.victory?.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", Tone.now());
        const playDefeatSound = () => synths.defeat?.triggerAttackRelease(["C3", "A2"], "2n");
        const playUiClickSound = () => synths.uiClick?.triggerAttackRelease("C5", "16n");

        // --- Navigation & UI Helpers ---
        function navigateTo(viewId, ...args) {
            // Stop any running animations when navigating away
            if (pokedexAnimationId) {
                cancelAnimationFrame(pokedexAnimationId);
                pokedexAnimationId = null;
            }
            if (battleAnimationId) {
                cancelAnimationFrame(battleAnimationId);
                battleAnimationId = null;
            }

            views.forEach(v => v.classList.remove('active'));
            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.classList.add('active');
                window.scrollTo(0, 0);
                const renderFunctionName = `render${viewId.charAt(0).toUpperCase() + viewId.slice(1).replace(/-./g, x=>x[1].toUpperCase())}`;
                if (window[renderFunctionName] && typeof window[renderFunctionName] === 'function') {
                    window[renderFunctionName](...args);
                }
            }
        }
        window.navigateTo = navigateTo;
        
        function setLoadingState(isLoading) {
            generateBtn.disabled = isLoading;
            if (isLoading) {
                btnText.textContent = '생성 중...';
            } else {
                btnText.textContent = '크리처 소환! (1 크레딧)';
            }
        }

        function showModal(title, content, onConfirm) {
            const modalHTML = `
                <div id="modal-overlay" class="modal-overlay">
                    <div class="modal-content w-full max-w-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold">${title}</h2>
                            <button id="close-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
                        </div>
                        <div class="text-gray-300">${content}</div>
                        ${onConfirm ? '<div class="mt-6 flex justify-end gap-3"><button id="confirm-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg">확인</button><button id="cancel-btn" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">취소</button></div>' : ''}
                    </div>
                </div>
            `;
            modalContainer.innerHTML = modalHTML;
            document.getElementById('close-modal-btn').onclick = closeModal;
            const overlay = document.getElementById('modal-overlay');
            overlay.onclick = (e) => { if (e.target === overlay) closeModal(); };
            if (onConfirm) {
                document.getElementById('confirm-btn').onclick = () => { onConfirm(); closeModal(); };
                document.getElementById('cancel-btn').onclick = closeModal;
            }
        }

        function closeModal() {
            modalContainer.innerHTML = '';
        }
        window.closeModal = closeModal;

        function showTypeChartModal() {
            let chartHtml = '<div class="type-chart-grid">';
            const types = Object.keys(typeTranslations);
            chartHtml += types.map(attacker => {
                let cellHtml = `<div class="type-chart-cell type-${attacker}"><strong>${typeTranslations[attacker]}</strong><div class="text-xs mt-1">`;
                const effectiveness = typeChart[attacker] || {};
                cellHtml += Object.keys(effectiveness).map(defender => {
                    const multiplier = effectiveness[defender];
                    const defenderKorean = typeTranslations[defender] || defender;
                    if (multiplier === 2) return ` <span class="font-bold text-green-300">${defenderKorean}(2x)</span>`;
                    if (multiplier === 0.5) return ` <span class="font-bold text-red-300">${defenderKorean}(0.5x)</span>`;
                    if (multiplier === 0) return ` <span class="font-bold text-gray-400">${defenderKorean}(0x)</span>`;
                    return '';
                }).join('');
                return cellHtml + '</div></div>';
            }).join('');
            chartHtml += '</div>';
            showModal('타입 상성표', chartHtml);
        }

        function showRarityModal() {
            const content = `
                <table class="w-full text-left text-gray-300">
                    <thead><tr class="bg-gray-700"><th class="p-2">등급</th><th class="p-2">총 능력치 (BST)</th><th class="p-2">확률</th></tr></thead>
                    <tbody>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-신화">신화</span></td><td class="p-2">780 ~</td><td class="p-2">5%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-고대">고대</span></td><td class="p-2">660 - 779</td><td class="p-2">10%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-전설">전설</span></td><td class="p-2">540 - 659</td><td class="p-2">15%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-에픽">에픽</span></td><td class="p-2">420 - 539</td><td class="p-2">20%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-희귀">희귀</span></td><td class="p-2">300 - 419</td><td class="p-2">25%</td></tr>
                        <tr><td class="p-2"><span class="rarity-badge rarity-일반">일반</span></td><td class="p-2">~ 299</td><td class="p-2">25%</td></tr>
                    </tbody>
                </table>
            `;
            showModal('캐릭터 등급표', content);
        }

        function updateUIBasedOnAuthState() {
            navLinks.innerHTML = '';
            if (currentUser && currentProfile) {
                const nickname = currentProfile.nickname || currentUser.email.split('@')[0];
                navLinks.innerHTML = `
                    <span class="font-bold text-sm sm:text-base text-gray-300 hidden md:inline">환영합니다, ${nickname}님!</span>
                    <span class="font-bold text-sm sm:text-base text-yellow-400">크레딧: ${currentProfile.credits}</span>
                    <button class="font-bold text-sm sm:text-base text-[#8abeb7] hover:underline p-2" id="profile-btn">마이페이지</button>
                    ${currentProfile.is_admin ? `<button id="admin-btn" class="font-bold text-sm sm:text-base text-[#c9c] hover:underline p-2">관리자</button>` : ''}
                    <button id="logout-btn" class="font-bold text-sm sm:text-base text-[#c99] hover:underline p-2">로그아웃</button>
                `;
                document.getElementById('profile-btn').onclick = () => navigateTo('profile-view', currentUser.id);
                if (currentProfile.is_admin) document.getElementById('admin-btn').onclick = () => navigateTo('admin-view');
                document.getElementById('logout-btn').onclick = handleLogout;
                characterCreationSection.style.display = 'block';
                goToBattleBtn.disabled = false;
            } else {
                navLinks.innerHTML = `<button id="login-signup-btn" class="font-bold text-[#8abeb7] hover:underline p-2">로그인 / 회원가입</button>`;
                document.getElementById('login-signup-btn').onclick = () => navigateTo('auth-view');
                characterCreationSection.style.display = 'none';
                goToBattleBtn.disabled = true;
            }
        }

        // --- Data Fetching & Realtime ---
        async function initialDataLoad() {
            try {
                // Fetch profiles first, as they are needed for characters
                const { data: profilesData, error: profilesError } = await supabaseClient.from('battle_profiles').select('*');
                if (profilesError) throw profilesError;
                allProfiles = profilesData;

                if (currentUser) {
                    currentProfile = allProfiles.find(p => p.id === currentUser.id);
                }
                
                // Reset and fetch first page of characters
                allCharacters = [];
                currentPage = 0;
                await loadMoreCharacters();
                
                updateUIBasedOnAuthState();
                navigateTo('pokedex-view');

            } catch (error) {
                console.error("Error on initial data load:", error);
                showModal('데이터 로딩 오류', `<p>데이터를 불러오는 데 실패했습니다: ${error.message}</p>`);
            }
        }

        function handleRealtimeChanges(payload) {
            console.log('Realtime change received:', payload);
            const { eventType, new: newRecord, old: oldRecord, table } = payload;
            let id = eventType === 'DELETE' ? oldRecord.id : newRecord.id;

            if (table === 'battle_characters') {
                const index = allCharacters.findIndex(c => c.id === id);

                if (eventType === 'INSERT') {
                    const newChar = { 
                        ...newRecord.data, 
                        id: newRecord.id, 
                        created_at: newRecord.created_at, 
                        creator_id: newRecord.creator_id, 
                        rank_points: newRecord.rank_points, 
                        image_url: newRecord.image_url, 
                        profile: allProfiles.find(p => p.id === newRecord.creator_id) 
                    };
                    allCharacters.unshift(newChar); // Add to the beginning of the list
                } else if (eventType === 'UPDATE') {
                    if (index > -1) {
                        // Construct the full, updated character object from the payload
                        const updatedCharacter = {
                            ...newRecord.data,
                            id: newRecord.id,
                            created_at: newRecord.created_at,
                            creator_id: newRecord.creator_id,
                            rank_points: newRecord.rank_points,
                            image_url: newRecord.image_url,
                            profile: allProfiles.find(p => p.id === newRecord.creator_id)
                        };
                        allCharacters[index] = updatedCharacter;
                    }
                } else if (eventType === 'DELETE') {
                    if (index > -1) {
                        allCharacters.splice(index, 1);
                    }
                }
            } else if (table === 'battle_profiles') {
                const index = allProfiles.findIndex(p => p.id === id);
                if (eventType === 'INSERT' && index === -1) {
                    allProfiles.push(newRecord);
                } else if (eventType === 'UPDATE' && index > -1) {
                    allProfiles[index] = { ...allProfiles[index], ...newRecord };
                }
            }
            
            const activeView = document.querySelector('.view.active');
            if (activeView && activeView.id !== 'battle-arena-view') {
                const renderFunctionName = `render${activeView.id.charAt(0).toUpperCase() + activeView.id.slice(1).replace(/-./g, x=>x[1].toUpperCase())}`;
                 if (window[renderFunctionName] && typeof window[renderFunctionName] === 'function') {
                       const currentId = activeView.dataset.id;
                       window[renderFunctionName](currentId);
                 }
            }
            if (document.getElementById('pokedex-view').classList.contains('active')) {
                 renderPokedexView();
                 renderRankingPodium();
            }
            if (currentUser && currentProfile && id === currentUser.id) {
                currentProfile = allProfiles.find(p => p.id === currentUser.id);
                updateUIBasedOnAuthState();
            }
        }

        function subscribeToChanges() {
            if (characterSubscription) characterSubscription.unsubscribe();
            characterSubscription = supabaseClient.channel('hipoketmon-db-changes')
                .on('postgres_changes', { event: '*', schema: 'public' }, handleRealtimeChanges)
                .subscribe();
        }

        // --- Authentication ---
        async function listenToAuthStateChanges() {
            supabaseClient.auth.onAuthStateChange(async (_event, session) => {
                currentUser = session?.user || null;
                currentProfile = currentUser ? allProfiles.find(p => p.id === currentUser.id) : null;
                if (_event === 'SIGNED_IN' && !currentProfile) {
                    const { data } = await supabaseClient.from('battle_profiles').select('*');
                    if(data) allProfiles = data;
                    currentProfile = allProfiles.find(p => p.id === currentUser.id);
                }
                updateUIBasedOnAuthState();
                if (!currentUser) navigateTo('pokedex-view');
            });
        }

        async function handleSignup(e) {
            e.preventDefault();
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;
            const { error } = await supabaseClient.auth.signUp({ email, password });
            if (error) authError.textContent = `회원가입 오류: ${error.message}`;
            else {
                authError.textContent = '';
                showModal('회원가입 성공!', '<p>성공적으로 가입되었습니다. 잠시 후 자동으로 로그인됩니다.</p>');
            }
        }

        async function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
            if (error) authError.textContent = `로그인 오류: ${error.message}`;
            else {
                authError.textContent = '';
                navigateTo('pokedex-view');
            }
        }

        async function handleLogout() {
            await supabaseClient.auth.signOut();
        }
        
        // --- Character Generation ---
        function determineRarityAndBST() {
            const rarityPool = [];
            for (let i = 0; i < 5; i++) rarityPool.push({ rarity: '신화', bstRange: { min: 780, max: 850 } });
            for (let i = 0; i < 10; i++) rarityPool.push({ rarity: '고대', bstRange: { min: 660, max: 779 } });
            for (let i = 0; i < 15; i++) rarityPool.push({ rarity: '전설', bstRange: { min: 540, max: 659 } });
            for (let i = 0; i < 20; i++) rarityPool.push({ rarity: '에픽', bstRange: { min: 420, max: 539 } });
            for (let i = 0; i < 25; i++) rarityPool.push({ rarity: '희귀', bstRange: { min: 300, max: 419 } });
            for (let i = 0; i < 25; i++) rarityPool.push({ rarity: '일반', bstRange: { min: 250, max: 299 } });
            
            const randomIndex = Math.floor(Math.random() * rarityPool.length);
            return rarityPool[randomIndex];
        }

        async function generateCharacter() {
            if (!currentUser) { showModal('로그인 필요', '<p>캐릭터를 생성하려면 로그인이 필요합니다.</p>'); navigateTo('auth-view'); return; }
            
            const { data: freshProfile, error: profileError } = await supabaseClient.from('battle_profiles').select('credits').eq('id', currentUser.id).single();
            if (profileError) { showModal('오류', `<p>프로필 정보를 불러오는 데 실패했습니다: ${profileError.message}</p>`); return; }
            currentProfile.credits = freshProfile.credits;
            updateUIBasedOnAuthState();

            if (currentProfile.credits < 1) { showModal('크레딧 부족', '<p>크레딧이 부족합니다. 매일 마이페이지에서 출석체크로 크레딧을 얻으세요!</p>'); return; }
            
            const userPrompt = promptInput.value.trim();
            if (!userPrompt) { errorMessage.textContent = '생성할 캐릭터에 대한 아이디어를 입력해주세요.'; return; }
            
            setLoadingState(true);
            errorMessage.textContent = '캐릭터 컨셉 구상 중... (최대 1분 소요)';
            
            try {
                const universe = universeSelect.value;
                const { rarity, bstRange } = determineRarityAndBST();
                const [imageUrlBase64, newCharData] = await Promise.all([ generateCharacterImage(userPrompt, universe), generateCharacterData(userPrompt, universe, rarity, bstRange) ]);
                
                errorMessage.textContent = '캐릭터를 현실 세계로 소환하는 중...';
                
                const imageBlob = base64ToBlob(imageUrlBase64, 'image/png');
                const filePath = `${currentUser.id}/${Date.now()}.png`;
                const { error: uploadError } = await supabaseClient.storage.from('battle_images').upload(filePath, imageBlob);
                if (uploadError) throw uploadError;

                const { data: { publicUrl } } = supabaseClient.storage.from('battle_images').getPublicUrl(filePath);
                
                const universeName = universe.replace(/_/g, ' ');
                const finalCharacterData = { ...newCharData, rarity, universe: universeName };

                const { error: insertError } = await supabaseClient.from('battle_characters').insert({ creator_id: currentUser.id, image_url: publicUrl, data: finalCharacterData });
                if (insertError) throw insertError;
                
                const { error: creditError } = await supabaseClient.from('battle_profiles').update({ credits: currentProfile.credits - 1 }).eq('id', currentUser.id);
                if (creditError) throw creditError;
                
                currentProfile.credits -= 1;
                updateUIBasedOnAuthState();

                promptInput.value = '';
                errorMessage.textContent = '';
                showModal('생성 성공!', `<p>새로운 캐릭터 <strong>${finalCharacterData.name}</strong>(${rarity})이(가) 도감에 추가되었습니다!</p>`);

            } catch (error) {
                console.error("Character Generation Error:", error);
                showModal('생성 실패', `<p>생성 중 오류가 발생했습니다. 크레딧은 차감되지 않았습니다. <br>오류: ${error.message}</p>`);
                errorMessage.textContent = `⚠️ 생성 중 오류가 발생했습니다.`;
            } finally {
                setLoadingState(false);
            }
        }
        
        async function callApiWithRetry(apiUrl, payload, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        if (response.status === 429) { await new Promise(res => setTimeout(res, delay * (i + 1))); continue; }
                        throw new Error(`API Error (${response.status}): ${await response.text()}`);
                    }
                    return response.json();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(res => setTimeout(res, delay * (i + 1)));
                }
            }
        }

        async function generateCharacterImage(prompt, universe) {
            const apiKey = ""; // The environment will inject the key.
            let stylePrompt = "";
            switch (universe) {
                case "감성의_숲": stylePrompt = "modern animation style, warm and vibrant colors, gentle and friendly appearance"; break;
                case "악몽의_저택": stylePrompt = "dark fantasy horror art, eerie and twisted, gothic elements"; break;
                case "사이버_펑크": stylePrompt = "cyberpunk mechanic style, neon lights, intricate details, robotic and futuristic"; break;
                case "판타지_왕국": stylePrompt = "western fantasy illustration style, classic fantasy elements, epic and majestic"; break;
                case "수정_동굴": stylePrompt = "mystical crystal style, glowing and translucent, ethereal and magical"; break;
                default: stylePrompt = "high-quality anime style"; break;
            }
            
            const fullPrompt = `Generate a full-body image of a creature. The user's core concept is: "${prompt}". This creature belongs to the '${universe.replace(/_/g, ' ')}' universe. Apply the following artistic style to the creature: "${stylePrompt}". The final image must be on a clean, white background, showing the entire creature from head to toe.`;
            
            const payload = { instances: [{ prompt: fullPrompt }], parameters: { "sampleCount": 1 } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
            const result = await callApiWithRetry(apiUrl, payload);

            if (result.predictions?.[0]?.bytesBase64Encoded) {
                return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
            }
            throw new Error("Image data was not returned from the API.");
        }

        async function generateCharacterData(prompt, universe, rarity, bstRange) {
            const apiKey = ""; // The environment will inject the key.
            const skillListForPrompt = Object.entries(MASTER_SKILL_LIST).map(([id, skill]) => `- ${id}: ${skill.text}`).join('\n');
            const abilityListForPrompt = Object.entries(MASTER_ABILITY_LIST).map(([id, ability]) => `- ${id}: ${ability.text}`).join('\n');
            
            const basePrompt = `
**절대 규칙:**
1.  **등급:** "${rarity}"
2.  **총 능력치 (BST):** 반드시 ${bstRange.min}과 ${bstRange.max} 사이의 값으로 생성해야 합니다.
3.  **기술 선택:** 아래 '마스터 스킬 리스트'에서 주어진 크리처 컨셉에 가장 어울리는 기술 ID 4개를 선택해야 합니다.
4.  **특성 선택:** 아래 '마스터 특성 리스트'에서 일반 특성(ability)과 숨겨진 특성(hiddenAbility)에 해당하는 ID를 각각 1개씩 선택해야 합니다.

**생성 지침:**
1.  **능력치 (Stats):** 주어진 BST 범위 내에서 능력치를 분배해주세요. 체력(HP)은 다른 스탯보다 4~6배 높게 설정하여 배틀이 길게 이어지도록 해주세요.
2.  **타입 (Types):** 캐릭터의 설명에 가장 어울리는 타입을 2개 부여해주세요. 타입은 (${Object.keys(typeTranslations).join(', ')}) 중에서만 선택해야 합니다.
3.  **기술 및 특성 이름/설명:** 당신이 선택한 4개의 기술 ID와 2개의 특성 ID에 대해, 크리처의 컨셉에 맞는 창의적이고 멋진 '이름(name)'을 새로 만들어주세요.

**마스터 스킬 리스트:**
${skillListForPrompt}

**마스터 특성 리스트:**
${abilityListForPrompt}

**중요:** 모든 결과물(name, classification, pokedexEntry, moves.name, ability.name 등)은 반드시 한국어로 작성해주세요.

**사용자 컨셉:** "${prompt}". 이 크리처는 '${universe.replace(/_/g, ' ')}' 세계관의 존재입니다.

JSON 스키마에 맞춰 답변해주세요.
`;
            const schema = {
                type: "OBJECT",
                properties: {
                    name: { type: "STRING" },
                    classification: { type: "STRING" },
                    types: { type: "ARRAY", items: { type: "STRING" } },
                    ability: { type: "OBJECT", properties: { id: { type: "STRING" }, name: { type: "STRING" } } },
                    hiddenAbility: { type: "OBJECT", properties: { id: { type: "STRING" }, name: { type: "STRING" } } },
                    height: { type: "NUMBER" },
                    weight: { type: "NUMBER" },
                    pokedexEntry: { type: "STRING" },
                    stats: { type: "OBJECT", properties: { hp: { type: "INTEGER" }, attack: { type: "INTEGER" }, defense: { type: "INTEGER" }, sp_atk: { type: "INTEGER" }, sp_def: { type: "INTEGER" }, speed: { type: "INTEGER" } } },
                    moves: { type: "ARRAY", items: { type: "OBJECT", properties: { moveId: { type: "STRING" }, name: { type: "STRING" }, description: { type: "STRING" }, type: { type: "STRING" } } } }
                },
                required: ["name", "classification", "types", "ability", "hiddenAbility", "pokedexEntry", "stats", "moves"]
            };
            const payload = { contents: [{ parts: [{ text: basePrompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const result = await callApiWithRetry(apiUrl, payload);
            if (result.candidates?.[0]?.content.parts[0].text) return JSON.parse(result.candidates[0].content.parts[0].text);
            throw new Error("Character data generation failed.");
        }
        
        // --- [UPDATED & REBALANCED] Battle & Ranking Logic ---
        const statStageMultipliers = {
            '-6': 2/8, '-5': 2/7, '-4': 2/6, '-3': 2/5, '-2': 2/4, '-1': 2/3,
            '0': 1,
            '1': 3/2, '2': 4/2, '3': 5/2, '4': 6/2, '5': 7/2, '6': 8/2
        };

        function getStatMultiplier(stage) {
            return statStageMultipliers[stage] || 1;
        }

        function calculateDamage(attacker, defender, move, isDesperate) {
            const masterMove = MASTER_SKILL_LIST[move.moveId];
            if (masterMove.type !== 'damage' || !masterMove.power) return { damage: 0, isCritical: false, effectiveness: 1 };
            
            let basePower = masterMove.power;
            // Technician Ability
            if (attacker.battleStatus.ability?.id === 'TECHNICIAN' && basePower <= 60) {
                basePower *= 1.5;
            }

            // Conditional Power
            if (masterMove.conditional === 'status' && defender.battleStatus.status) {
                basePower *= masterMove.multiplier;
            }
            if (masterMove.conditional === 'low_hp' && (attacker.battleStatus.hp / attacker.stats.hp) <= (1/3)) {
                basePower *= 2.5;
            }

            let atkStat, defStat;
            if (masterMove.category === 'Physical') {
                atkStat = attacker.stats.attack * getStatMultiplier(attacker.battleStatus.stat_stages.attack);
                defStat = defender.stats.defense * getStatMultiplier(defender.battleStatus.stat_stages.defense);
            } else { // Special
                atkStat = attacker.stats.sp_atk * getStatMultiplier(attacker.battleStatus.stat_stages.sp_atk);
                defStat = defender.stats.sp_def * getStatMultiplier(defender.battleStatus.stat_stages.sp_def);
            }

            // Guts Ability
            if (attacker.battleStatus.ability?.id === 'GUTS' && attacker.battleStatus.status && masterMove.category === 'Physical') {
                atkStat *= 1.5;
            }
            
            if (isDesperate) atkStat *= 1.25;

            let damage = (((2 * 40 / 5 + 2) * atkStat * basePower / defStat) / 50) + 2;
            
            let effectiveness = 1;
            defender.types.forEach(defType => {
                const moveTypeKey = Object.keys(typeTranslations).find(key => typeTranslations[key] === move.type) || move.type;
                effectiveness *= typeChart[moveTypeKey]?.[defType] ?? 1;
            });
            if (attacker.types.some(t => typeTranslations[t] === move.type)) damage *= 1.5;
            damage *= effectiveness;
            const isCritical = Math.random() < (isDesperate ? 0.25 : 0.15); // 15% base crit chance
            if (isCritical) damage *= 1.5;
            
            let finalDamage = Math.floor(damage);
            if (defender.battleStatus.shield > 0) {
                const shieldDamage = Math.min(defender.battleStatus.shield, finalDamage);
                finalDamage -= shieldDamage;
                defender.battleStatus.shield -= shieldDamage;
            }

            return { damage: finalDamage, isCritical, effectiveness };
        }

        async function updatePostBattleStats(winner, loser) {
            // 1. Update Ranks (Elo)
            const K = 32;
            const winnerRank = winner.rank_points || 1000;
            const loserRank = loser.rank_points || 1000;
            const winnerExpected = 1 / (1 + 10 ** ((loserRank - winnerRank) / 400));
            const newWinnerRank = Math.round(winnerRank + K * (1 - winnerExpected));
            const newLoserRank = Math.max(0, Math.round(loserRank + K * (0 - (1 - winnerExpected))));
            
            // 2. Update Battle Records (W/L) using RPC
            const { error: winnerRecordError } = await supabaseClient.rpc('update_battle_record', { char_id: winner.id, is_win: true });
            const { error: loserRecordError } = await supabaseClient.rpc('update_battle_record', { char_id: loser.id, is_win: false });

            if (winnerRecordError) console.error("Error updating winner record:", winnerRecordError);
            if (loserRecordError) console.error("Error updating loser record:", loserRecordError);

            // 3. Update Ranks in the characters table
            await Promise.all([
                supabaseClient.from('battle_characters').update({ rank_points: newWinnerRank }).eq('id', winner.id),
                supabaseClient.from('battle_characters').update({ rank_points: newLoserRank }).eq('id', loser.id)
            ]);

            // 4. Grant Experience to the winner
            await supabaseClient.rpc('grant_experience_and_level_up', { char_id: winner.id, xp_to_add: 50 });


            return { rankChange: newWinnerRank - winnerRank, newWinnerRank, newLoserRank };
        }
        
        // --- Helper Functions ---
        function base64ToBlob(base64, contentType = '', sliceSize = 512) {
            const byteCharacters = atob(base64.split(',')[1]);
            const byteArrays = [];
            for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                const slice = byteCharacters.slice(offset, offset + sliceSize);
                const byteNumbers = new Array(slice.length);
                for (let i = 0; i < slice.length; i++) byteNumbers[i] = slice.charCodeAt(i);
                byteArrays.push(new Uint8Array(byteNumbers));
            }
            return new Blob(byteArrays, { type: contentType });
        }
        
        // --- Rendering Functions ---
        window.renderPokedexView = function() {
            initPokedexBackground(); // Start the background animation
            renderRankingPodium();
            
            pokedexContainer.innerHTML = ''; // Clear existing cards before rendering
            
            if (allCharacters.length === 0 && !isLoadingMore) {
                emptyState.style.display = 'block';
                pokedexContainer.style.display = 'none';
            } else {
                emptyState.style.display = 'none';
                pokedexContainer.style.display = 'grid';
                allCharacters.forEach(char => {
                    if (!document.getElementById(`char-card-${char.id}`)) {
                        pokedexContainer.appendChild(createCharacterCard(char));
                    }
                });
            }
            updatePaginationControls();
        };

        function createCharacterCard(char) {
            if (!char.stats) {
                console.warn("Character missing stats, skipping render:", char);
                return document.createDocumentFragment(); // Return an empty element
            }
            
            const bst = Object.values(char.stats).reduce((a, b) => a + b, 0);
            const hasStatusMove = char.moves.some(m => m && m.moveId && MASTER_SKILL_LIST[m.moveId]?.type === 'status');
            const isHighRarity = ['전설', '고대', '신화'].includes(char.rarity);
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            const level = char.level || 0;
            
            const card = document.createElement('div');
            card.id = `char-card-${char.id}`;

            let rarityClass = `card-rarity-${char.rarity}`;
            if (isHighRarity) {
                rarityClass += ' shimmer-effect';
            }

            card.className = `pokedex-card rounded-lg shadow-md p-4 card-border-${char.rarity} ${rarityClass}`;
            
            // Use Supabase image optimization and lazy loading
            const imageUrl = `${char.image_url}?width=320&quality=80`;

            card.innerHTML = `
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="relative w-full sm:w-40 h-40 bg-gray-700 rounded-lg flex items-center justify-center">
                        <div class="level-display">LV.${level}</div>
                        <img src="${imageUrl}" alt="${char.name}" class="absolute top-0 left-0 w-full h-full object-cover rounded-lg" loading="lazy"
                             onerror="this.parentElement.innerHTML = '<span class=\'text-xs text-gray-400\'>Image Error</span>';">
                    </div>
                    <div class="flex-1">
                        <h3 class="font-bold text-xl">${char.name} <span class="text-sm text-gray-500">(${char.classification})</span></h3>
                        <div class="flex items-center gap-2 my-1"><span class="rarity-badge rarity-${char.rarity}">${char.rarity}</span><span class="universe-badge universe-${char.universe.replace(' ', '_')}">${char.universe}</span></div>
                        <div class="flex gap-2 my-2">${char.types.map(t => `<span class="type-badge type-${t}">${typeTranslations[t] || t}</span>`).join('')}</div>
                        <p class="text-sm text-gray-400">소환사: <a href="#" data-profile-id="${char.creator_id}" class="text-[#8abeb7] hover:underline">${creatorName}</a></p>
                    </div>
                </div>
                <div class="mt-4">
                    <div class="text-xs font-bold text-gray-500 mb-1">능력치 (BST: ${bst})</div>
                    ${Object.entries(char.stats).map(([stat, value]) => `<div class="flex items-center gap-2 text-xs mb-1"><span class="w-12 font-semibold text-gray-400">${{hp:'HP', attack:'공격', defense:'방어', sp_atk:'특공', sp_def:'특방', speed:'속도'}[stat]}</span><div class="flex-1 stat-bar-bg"><div class="stat-bar h-2 bg-[#8abeb7]" style="width: ${Math.min(100, (value / (stat === 'hp' ? 300 : 150)) * 100)}%;"></div></div><span class="w-8 text-right font-bold">${value}</span></div>`).join('')}
                </div>
                <div class="rank-display">${char.rank_points || 'Unranked'}</div>
            `;
            
            card.onclick = () => navigateTo('detail-view', char.id);
            card.querySelector('[data-profile-id]').onclick = (e) => { e.stopPropagation(); navigateTo('profile-view', e.target.dataset.profileId); };
            return card;
        }

        async function loadMoreCharacters() {
            if (isLoadingMore) return;
            isLoadingMore = true;

            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                loadMoreBtn.textContent = '불러오는 중...';
                loadMoreBtn.disabled = true;
            }

            const from = currentPage * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;

            let query = supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)', { count: 'exact' })
                .order('created_at', { ascending: false })
                .range(from, to);
            
            if (activeFilter !== 'all') {
                const universeName = activeFilter.replace(/_/g, ' ');
                query = query.eq('data->>universe', universeName);
            }

            const { data, error, count } = await query;

            if (error) {
                console.error("Error fetching more characters:", error);
                showModal('오류', '캐릭터를 더 불러오는 데 실패했습니다.');
            } else {
                totalCharacterCount = count;
                const newCharacters = data.map(c => ({ ...c.data, id: c.id, created_at: c.created_at, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile }));
                allCharacters.push(...newCharacters);
                currentPage++;
                renderPokedexView();
            }
            isLoadingMore = false;
        }

        function updatePaginationControls() {
            paginationControls.innerHTML = '';
            if (allCharacters.length < totalCharacterCount) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-btn';
                loadMoreBtn.className = 'bg-gray-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600';
                loadMoreBtn.textContent = '더 보기';
                loadMoreBtn.onclick = loadMoreCharacters;
                paginationControls.appendChild(loadMoreBtn);
            }
        }
        
        window.renderDetailView = async function(characterId) {
            detailViewContainer.innerHTML = '';
            const currentId = Number(characterId);
            detailViewContainer.dataset.id = currentId;
            
            // Find in cache first, if not found, fetch from DB
            let char = allCharacters.find(c => c.id === currentId);
            if (!char) {
                const { data, error } = await supabaseClient.from('battle_characters').select('*, profile:battle_profiles(id, nickname, email)').eq('id', currentId).single();
                if (error || !data) {
                    detailViewContainer.innerHTML = `<p class="text-center p-8">크리처를 찾을 수 없습니다.</p>`; return;
                }
                char = { ...data.data, id: data.id, created_at: data.created_at, creator_id: data.creator_id, rank_points: data.rank_points, image_url: data.image_url, profile: data.profile };
            }

            if (!char.stats) { 
                detailViewContainer.innerHTML = `<p class="text-center p-8">크리처 데이터가 손상되었습니다.</p>`; 
                return; 
            }

            const { data: comments, error } = await supabaseClient.from('battle_comments').select('*, profile:battle_profiles(id, nickname, email)').eq('character_id', currentId).order('created_at', { ascending: false });
            if (error) console.error("Error fetching comments:", error);

            const { data: record, error: recordError } = await supabaseClient.from('battle_records').select('wins, losses').eq('character_id', currentId).single();
            if (recordError) console.log("No battle record found for this character yet.");


            const bst = Object.values(char.stats).reduce((a, b) => a + b, 0);
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            
            const { data: rankData } = await supabaseClient.rpc('get_character_rank', { char_id: char.id });
            const rank = rankData || 'N/A';
            const badgeHTML = getRankBadge(rank);
            const imageUrl = `${char.image_url}?width=512&quality=85`;

            // Handle both old (string) and new (object) ability data structures
            const getAbilityHTML = (ability) => {
                if (typeof ability === 'string') {
                    return `<span><b>특성:</b> ${ability}</span>`;
                }
                if (typeof ability === 'object' && ability !== null && ability.id) {
                    const masterAbility = MASTER_ABILITY_LIST[ability.id];
                    return `<span title="${masterAbility?.text || '효과 설명 없음'}"><b>특성:</b> ${ability.name} ℹ️</span>`;
                }
                return '<span><b>특성:</b> 미정</span>';
            };
            const getHiddenAbilityHTML = (ability) => {
                if (typeof ability === 'string') {
                    return `<span><b>숨겨진 특성:</b> ${ability}</span>`;
                }
                if (typeof ability === 'object' && ability !== null && ability.id) {
                    const masterAbility = MASTER_ABILITY_LIST[ability.id];
                    return `<span title="${masterAbility?.text || '효과 설명 없음'}"><b>숨겨진 특성:</b> ${ability.name} ℹ️</span>`;
                }
                return '<span><b>숨겨진 특성:</b> 미정</span>';
            };


            detailViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
                    <div class="bg-gray-800 rounded-2xl shadow-xl overflow-hidden">
                        <div class="p-6 md:p-8">
                            <div class="flex flex-col md:flex-row gap-8">
                                <div class="md:w-1/3 text-center">
                                    <img src="${imageUrl}" alt="${char.name}" class="w-full h-auto object-cover rounded-lg shadow-lg mx-auto" onerror="this.onerror=null;this.src='https://placehold.co/256x256/e0e0e0/757575?text=Image+Not+Found';">
                                    ${(currentUser?.id === char.creator_id || currentProfile?.is_admin) ? `<button id="delete-char-btn" class="mt-4 bg-[#c99] text-white font-bold py-2 px-4 rounded-lg w-full">크리처 삭제</button>` : ''}
                                </div>
                                <div class="md:w-2/3">
                                    <h2 class="font-title text-4xl">${char.name} <span class="text-2xl text-gray-400">(${char.classification})</span></h2>
                                    <div class="flex items-center gap-2 my-2"><span class="rarity-badge rarity-${char.rarity}">${char.rarity}</span><span class="universe-badge universe-${char.universe.replace(' ', '_')}">${char.universe}</span></div>
                                    <div class="flex gap-2 my-3">${char.types.map(t => `<span class="type-badge type-${t}">${typeTranslations[t] || t}</span>`).join('')}</div>
                                    <p class="text-gray-300 my-4">${char.pokedexEntry}</p>
                                    <p class="text-sm text-gray-400">소환사: <a href="#" onclick="event.preventDefault(); navigateTo('profile-view', '${char.creator_id}')" class="text-[#8abeb7] hover:underline">${creatorName}</a></p>
                                    <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm mt-4">
                                        <span><b>키:</b> ${char.height}m</span>
                                        <span><b>몸무게:</b> ${char.weight}kg</span>
                                        ${getAbilityHTML(char.ability)}
                                        ${getHiddenAbilityHTML(char.hiddenAbility)}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="bg-gray-700/50 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">랭킹 정보</h3>
                            <div class="flex items-center gap-4">
                                ${badgeHTML}
                                <span class="text-lg font-bold text-yellow-400">${char.rank_points || 1000} RP</span>
                                <span class="text-lg font-bold text-gray-300">${record ? `${record.wins}승 ${record.losses}패` : '전적 없음'}</span>
                            </div>
                        </div>
                        <div class="bg-gray-800 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">능력치 (총합: ${bst})</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-2">
                                ${Object.entries(char.stats).map(([stat, value]) => `<div class="flex items-center gap-2 text-sm"><span class="w-16 font-semibold text-gray-400">${{hp:'HP', attack:'공격', defense:'방어', sp_atk:'특공', sp_def:'특방', speed:'속도'}[stat]}</span><div class="flex-1 stat-bar-bg"><div class="stat-bar h-3 bg-[#8abeb7]" style="width: ${Math.min(100, (value / (stat === 'hp' ? 300 : 150)) * 100)}%;"></div></div><span class="w-8 text-right font-bold">${value}</span></div>`).join('')}
                            </div>
                        </div>
                        <div class="bg-gray-700/50 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">기술</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                ${char.moves.map(move => {
                                    const masterMove = MASTER_SKILL_LIST[move.moveId] || {};
                                    const powerText = masterMove.type === 'damage' ? `위력: ${masterMove.power}` : '';
                                    const categoryText = masterMove.category ? `분류: ${masterMove.category}` : '';
                                    const effectText = masterMove.text || '';
                                    return `<div class="p-4 rounded-lg bg-gray-900/50 border border-gray-700"><p class="font-bold">${move.name} <span class="type-badge type-${Object.keys(typeTranslations).find(key => typeTranslations[key] === move.type) || move.type}">${move.type}</span></p><p class="text-sm text-gray-400 mt-1">${move.description}</p><div class="text-xs mt-2 flex justify-between"><span>${powerText}</span><span>${categoryText}</span></div><p class="text-xs text-amber-300 mt-1">효과: ${effectText}</p></div>`
                                }).join('')}
                            </div>
                        </div>
                        <div class="bg-gray-800 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">댓글</h3>
                            ${currentUser ? `<form id="comment-form" class="flex gap-2 mb-6"><input id="comment-input" type="text" placeholder="댓글을 입력하세요..." class="flex-1 p-2 border rounded-lg bg-gray-700 text-white border-gray-600" required><button type="submit" class="bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">등록</button></form>` : '<p class="text-center text-gray-500">댓글을 작성하려면 <a href="#" onclick="event.preventDefault(); navigateTo(\'auth-view\')" class="text-[#8abeb7] hover:underline">로그인</a>이 필요합니다.</p>'}
                            <div id="comments-container" class="space-y-4">${comments && comments.length > 0 ? comments.map(c => `<div class="flex gap-3"><div class="flex-1 bg-gray-900/50 p-3 rounded-lg border border-gray-700"><p class="text-sm">${c.content}</p><div class="text-xs text-gray-500 mt-2"><span>작성자: ${c.profile?.nickname || c.profile?.email?.split('@')[0]}</span><span class="mx-2">|</span><span>${new Date(c.created_at).toLocaleString()}</span></div></div>${(currentUser?.id === c.user_id || currentProfile?.is_admin) ? `<button data-comment-id="${c.id}" class="delete-comment-btn self-start text-red-500 hover:text-red-700 text-2xl">&times;</button>` : ''}</div>`).join('') : '<p class="text-center text-gray-500">아직 댓글이 없습니다.</p>'}</div>
                        </div>
                    </div>
                </div>
            `;

            if (currentUser?.id === char.creator_id || currentProfile?.is_admin) {
                document.getElementById('delete-char-btn').onclick = () => {
                    showModal('크리처 삭제 확인', `<p><strong>${char.name}</strong>을(를) 정말로 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.</p>`, async () => {
                        const { error } = await supabaseClient.from('battle_characters').delete().eq('id', char.id);
                        if (error) { showModal('삭제 오류', `<p>${error.message}</p>`); }
                        else { navigateTo('pokedex-view'); }
                    });
                };
            }

            if (currentUser) {
                document.getElementById('comment-form').onsubmit = async (e) => {
                    e.preventDefault();
                    const content = document.getElementById('comment-input').value;
                    if (!content.trim()) return;
                    const { error } = await supabaseClient.from('battle_comments').insert({ character_id: char.id, user_id: currentUser.id, content });
                    if (error) { showModal('댓글 등록 오류', `<p>${error.message}</p>`); }
                    else { renderDetailView(characterId); }
                };
            }
            
            document.querySelectorAll('.delete-comment-btn').forEach(btn => {
                btn.onclick = () => {
                    showModal('댓글 삭제 확인', '<p>정말로 이 댓글을 삭제하시겠습니까?</p>', async () => {
                        const { error } = await supabaseClient.from('battle_comments').delete().eq('id', btn.dataset.commentId);
                        if (error) { showModal('삭제 오류', `<p>${error.message}</p>`); }
                        else { renderDetailView(characterId); }
                    });
                };
            });
        };

        // --- BATTLE SELECTION VIEW (REFACTORED) ---
        function createBattleSelectionCard(char) {
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            const recordText = char.record ? `${char.record.wins || 0}승 ${char.record.losses || 0}패` : '전적 없음';
            const level = char.level || 0;
            return `
                <div class="pokedex-card rounded-lg shadow p-4 card-border-${char.rarity}">
                    <div class="flex flex-col sm:flex-row gap-4">
                        <div class="relative w-full sm:w-24 h-24 bg-gray-700 rounded-lg">
                            <div class="level-display">LV.${level}</div>
                            <img src="${char.image_url}?width=128&quality=80" alt="${char.name}" class="w-full h-full object-cover rounded-lg" loading="lazy" onerror="this.onerror=null;this.src='https://placehold.co/96x96/e0e0e0/757575?text=X';">
                        </div>
                        <div class="flex-1">
                            <h3 class="font-bold text-lg">${char.name}</h3>
                            <div class="flex items-center gap-2 my-1">
                                <span class="rarity-badge rarity-${char.rarity}" style="font-size: 0.7rem; padding: 2px 8px;">${char.rarity}</span>
                                <span class="universe-badge universe-${char.universe.replace(' ', '_')}">${char.universe}</span>
                            </div>
                            <div class="flex gap-1 my-2">
                                ${char.types.map(t => `<span class="type-badge type-${t}" style="font-size: 0.7rem; padding: 2px 8px;">${typeTranslations[t] || t}</span>`).join('')}
                            </div>
                            <p class="text-xs text-gray-400">랭크: ${char.rank_points || 1000} RP</p>
                            <p class="text-xs text-gray-400 mt-1">전적: ${recordText}</p>
                            <p class="text-xs text-gray-400 mt-1">소환사: ${creatorName}</p>
                        </div>
                    </div>
                </div>
            `;
        }

        window.renderBattleSelectionView = async function() {
            if (!currentUser) { navigateTo('auth-view'); return; }
            
            battleSelectionViewContainer.innerHTML = '';

            const { data: allCharsForBattle, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email), record:battle_records(wins, losses)');
            
            if (error) {
                showModal('오류', '캐릭터 목록을 불러오지 못했습니다.');
                battleSelectionViewContainer.innerHTML = '';
                return;
            }
            const battleReadyChars = allCharsForBattle.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile, record: c.record }));

            const myCharacters = battleReadyChars.filter(c => c.creator_id === currentUser.id);

            if (myCharacters.length === 0) {
                battleSelectionViewContainer.innerHTML = `<div class="text-center p-8 max-w-lg mx-auto bg-gray-800 rounded-lg shadow-md mt-10"><h2 class="text-2xl font-bold mb-4">크리처 없음</h2><p>배틀을 하려면 먼저 자신의 크리처를 소환해야 합니다.</p><button onclick="navigateTo('pokedex-view')" class="mt-4 bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">소환하러 가기</button></div>`;
                return;
            }

            let selectionHTML = `<div class="max-w-7xl mx-auto p-4"><h2 class="font-title text-3xl text-center mb-6">내보낼 크리처 선택</h2><div id="player-char-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div></div>`;
            battleSelectionViewContainer.innerHTML = selectionHTML;

            const playerListContainer = document.getElementById('player-char-list');
            myCharacters.forEach(char => {
                const card = document.createElement('div');
                card.innerHTML = createBattleSelectionCard(char);
                card.onclick = () => selectOpponent(char.id);
                playerListContainer.appendChild(card);
            });

            function selectOpponent(playerCharId) {
                const opponents = battleReadyChars.filter(c => c.id !== playerCharId);
                
                if (opponents.length === 0) {
                    battleSelectionViewContainer.innerHTML = `<div class="text-center p-8 max-w-lg mx-auto bg-gray-800 rounded-lg shadow-md mt-10"><h2 class="text-2xl font-bold mb-4">상대 없음</h2><p>배틀할 다른 크리처가 없습니다. 새로운 크리처가 소환될 때까지 기다려주세요.</p><button onclick="navigateTo('pokedex-view')" class="mt-4 bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">메인으로 돌아가기</button></div>`;
                    return;
                }

                let opponentHTML = `<div class="max-w-7xl mx-auto p-4"><h2 class="font-title text-3xl text-center mb-6">상대할 크리처 선택</h2><div id="opponent-char-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div></div>`;
                battleSelectionViewContainer.innerHTML = opponentHTML;
                const opponentListContainer = document.getElementById('opponent-char-list');
                opponents.forEach(char => {
                    const card = document.createElement('div');
                    card.innerHTML = createBattleSelectionCard(char);
                    card.onclick = () => navigateTo('battle-arena-view', playerCharId, char.id);
                    opponentListContainer.appendChild(card);
                });
            }
        };

        // --- BATTLE ARENA (REFACTORED with Three.js) ---
        window.renderBattleArenaView = async function(playerCharId, opponentCharId) {
            if (battleAnimationId) {
                cancelAnimationFrame(battleAnimationId);
            }
            if (!playerCharId || !opponentCharId) {
                navigateTo('pokedex-view');
                showModal('오류', '<p>배틀을 시작하는 중 오류가 발생했습니다. 다시 시도해주세요.</p>');
                return;
            }

            // Fetch full data for battle participants to ensure it's up to date
            const { data: participantsData, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .in('id', [playerCharId, opponentCharId]);

            if (error || participantsData.length < 2) {
                 navigateTo('pokedex-view');
                 showModal('오류', '<p>배틀 상대를 찾을 수 없거나 데이터가 손상되었습니다.</p>');
                 return;
            }
            
            const playerCharData = participantsData.find(p => p.id === Number(playerCharId));
            const opponentCharData = participantsData.find(p => p.id === Number(opponentCharId));

            const playerChar = { ...playerCharData.data, id: playerCharData.id, creator_id: playerCharData.creator_id, rank_points: playerCharData.rank_points, image_url: playerCharData.image_url, profile: playerCharData.profile };
            const opponentChar = { ...opponentCharData.data, id: opponentCharData.id, creator_id: opponentCharData.creator_id, rank_points: opponentCharData.rank_points, image_url: opponentCharData.image_url, profile: opponentCharData.profile };
            
            const randomBgUrl = battleBackgrounds[Math.floor(Math.random() * battleBackgrounds.length)];

            const playerCreatorName = playerChar.profile?.nickname || playerChar.profile?.email?.split('@')[0] || 'Unknown';
            const opponentCreatorName = opponentChar.profile?.nickname || opponentChar.profile?.email?.split('@')[0] || 'Unknown';

            battleArenaContainer.innerHTML = `
                <canvas id="battle-canvas"></canvas>
                <div class="battle-ui-overlay flex flex-col justify-between min-h-screen p-4 pb-40 text-white">
                    <!-- Opponent UI -->
                    <div class="flex justify-end items-start gap-4">
                        <div class="bg-gray-800/70 p-3 rounded-lg w-64 text-right">
                            <p class="font-bold">${opponentChar.name}</p>
                            <p class="text-xs text-gray-400">by ${opponentCreatorName}</p>
                            <div class="w-full bg-gray-600 rounded-full h-4 mt-1"><div id="opponent-hp-bar" class="hp-bar-inner bg-green-500 h-4 rounded-full" style="width: 100%"></div></div>
                            <p id="opponent-hp-text" class="text-sm mt-1">${opponentChar.stats.hp} / ${opponentChar.stats.hp}</p>
                            <div id="opponent-ability" class="text-xs mt-1 cursor-help" title="${MASTER_ABILITY_LIST[opponentChar.ability?.id]?.text || ''}">
                                <b>특성:</b> ${opponentChar.ability?.name || '없음'} ℹ️
                            </div>
                            <div id="opponent-hidden-ability" class="text-xs mt-1 cursor-help" title="${MASTER_ABILITY_LIST[opponentChar.hiddenAbility?.id]?.text || ''}">
                                <b>숨겨진 특성:</b> ${opponentChar.hiddenAbility?.name || '없음'} ℹ️
                            </div>
                            <div class="battle-moves-grid mt-2">
                                ${opponentChar.moves.map((move, i) => `<div id="opponent-move-${i}" data-move-id="${move.moveId}" class="battle-move-item">${move.name}</div>`).join('')}
                            </div>
                        </div>
                    </div>
                    <!-- Player UI -->
                    <div class="flex justify-start items-end gap-4">
                        <div class="bg-gray-800/70 p-3 rounded-lg w-64">
                            <p class="font-bold">${playerChar.name}</p>
                            <p class="text-xs text-gray-400">by ${playerCreatorName}</p>
                            <div class="w-full bg-gray-600 rounded-full h-4 mt-1"><div id="player-hp-bar" class="hp-bar-inner bg-green-500 h-4 rounded-full" style="width: 100%"></div></div>
                            <p id="player-hp-text" class="text-sm mt-1">${playerChar.stats.hp} / ${playerChar.stats.hp}</p>
                             <div id="player-ability" class="text-xs mt-1 cursor-help" title="${MASTER_ABILITY_LIST[playerChar.ability?.id]?.text || ''}">
                                <b>특성:</b> ${playerChar.ability?.name || '없음'} ℹ️
                            </div>
                            <div id="player-hidden-ability" class="text-xs mt-1 cursor-help" title="${MASTER_ABILITY_LIST[playerChar.hiddenAbility?.id]?.text || ''}">
                                <b>숨겨진 특성:</b> ${playerChar.hiddenAbility?.name || '없음'} ℹ️
                            </div>
                            <div class="battle-moves-grid mt-2">
                                ${playerChar.moves.map((move, i) => `<div id="player-move-${i}" data-move-id="${move.moveId}" class="battle-move-item">${move.name}</div>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div id="battle-log" class="absolute bottom-0 left-0 right-0 bg-black/50 p-4 overflow-y-auto text-sm z-10"></div>
            `;

            // --- Three.js Setup ---
            const canvas = document.getElementById('battle-canvas');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin("anonymous"); // Important for Supabase Storage
            
            // Background
            loader.load(randomBgUrl, (texture) => {
                scene.background = texture;
            });
            
            // Characters
            let playerSprite, opponentSprite;
            let playerBorder, opponentBorder;
            const playerImgUrl = `${playerChar.image_url}?width=512&quality=85`;
            const opponentImgUrl = `${opponentChar.image_url}?width=512&quality=85`;

            loader.load(playerImgUrl, (tex) => {
                const aspect = tex.image ? tex.image.width / tex.image.height : 1;
                const geometry = new THREE.PlaneGeometry(2 * aspect, 2);
                const material = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
                playerSprite = new THREE.Mesh(geometry, material);

                const highRarities = ['전설', '고대', '신화'];
                if (highRarities.includes(playerChar.rarity)) {
                    const borderColor = playerChar.rarity === '전설' ? 0xFFD700 : playerChar.rarity === '고대' ? 0x4DB6AC : 0xFF7043;
                    const borderMaterial = new THREE.MeshBasicMaterial({ color: borderColor, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
                    const borderGeometry = new THREE.PlaneGeometry(geometry.parameters.width * 1.1, geometry.parameters.height * 1.1);
                    playerBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                    playerBorder.position.z = -0.01; // Place it just behind
                    playerSprite.add(playerBorder);
                }

                scene.add(playerSprite);
                onAssetLoad();
            }, undefined, () => onAssetError('player'));

            loader.load(opponentImgUrl, (tex) => {
                const aspect = tex.image ? tex.image.width / tex.image.height : 1;
                const geometry = new THREE.PlaneGeometry(2 * aspect, 2);
                const material = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
                opponentSprite = new THREE.Mesh(geometry, material);

                const highRarities = ['전설', '고대', '신화'];
                if (highRarities.includes(opponentChar.rarity)) {
                    const borderColor = opponentChar.rarity === '전설' ? 0xFFD700 : opponentChar.rarity === '고대' ? 0x4DB6AC : 0xFF7043;
                    const borderMaterial = new THREE.MeshBasicMaterial({ color: borderColor, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
                    const borderGeometry = new THREE.PlaneGeometry(geometry.parameters.width * 1.1, geometry.parameters.height * 1.1);
                    opponentBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                    opponentBorder.position.z = -0.01; // Place it just behind
                    opponentSprite.add(opponentBorder);
                }

                scene.add(opponentSprite);
                onAssetLoad();
            }, undefined, () => onAssetError('opponent'));

            camera.position.z = 5;

            function updateCharacterPositions() {
                const vFOV = THREE.MathUtils.degToRad(camera.fov);
                const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
                const width = height * camera.aspect;

                if (playerSprite) playerSprite.position.x = -width / 4;
                if (opponentSprite) opponentSprite.position.x = width / 4;
            }

            // Animation Loop
            const clock = new THREE.Clock();
            function animate() {
                battleAnimationId = requestAnimationFrame(animate);
                const elapsedTime = clock.getElapsedTime();
                
                // Idle "breathing" animation
                if (playerSprite) playerSprite.position.y = -1 + Math.sin(elapsedTime * 2) * 0.1;
                if (opponentSprite) opponentSprite.position.y = 1 + Math.sin(elapsedTime * 2 + 1) * 0.1;

                // Rarity border pulsation
                const pulse = 1 + Math.sin(elapsedTime * 4) * 0.05; // Pulsates between 0.95 and 1.05
                if (playerBorder) {
                    playerBorder.scale.set(pulse, pulse, 1);
                }
                if (opponentBorder) {
                    opponentBorder.scale.set(pulse, pulse, 1);
                }

                renderer.render(scene, camera);
            }
            animate();
            
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                updateCharacterPositions();
            }
            window.addEventListener('resize', onWindowResize);
            updateCharacterPositions(); // Initial positioning

            // --- Battle Logic (Starts Here) ---
            const battleLog = document.getElementById('battle-log');
            let isBattleOver = false;
            
            const initBattleStatus = (char) => {
                const useHiddenAbility = Math.random() < 0.2; // 20% chance to use hidden ability
                const chosenAbility = useHiddenAbility ? char.hiddenAbility : char.ability;
                log(`<span class="log-ability">${char.name}의 특성은 「${chosenAbility.name}」!</span>`);

                return {
                    hp: char.stats.hp,
                    shield: 0,
                    status: null,
                    dots: [],
                    stat_stages: { attack: 0, defense: 0, sp_atk: 0, sp_def: 0, speed: 0 },
                    ability: chosenAbility,
                };
            };

            playerChar.battleStatus = initBattleStatus(playerChar);
            opponentChar.battleStatus = initBattleStatus(opponentChar);
            let turn = 1;

            let assetsLoaded = 0;
            const totalAssets = 2;

            const onAssetLoad = () => {
                assetsLoaded++;
                if (assetsLoaded === totalAssets) {
                    applyStartOfBattleAbilities();
                    setTimeout(battleLoop, 2000);
                }
            };

            const onAssetError = (spriteType) => {
                console.error(`${spriteType} image failed to load.`);
                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.MeshBasicMaterial({ color: 0x888888 });
                const placeholder = new THREE.Mesh(geometry, material);
                if (spriteType === 'player') {
                    playerSprite = placeholder;
                    scene.add(playerSprite);
                } else {
                    opponentSprite = placeholder;
                    scene.add(opponentSprite);
                }
                onAssetLoad();
            };


            function log(message) {
                battleLog.innerHTML += `<p>${message}</p>`;
                battleLog.scrollTop = battleLog.scrollHeight;
            }
            
            function applyStartOfBattleAbilities() {
                if (playerChar.battleStatus.ability?.id === 'INTIMIDATE') {
                    log(`<span class="log-ability">${playerChar.name}의 특성 「${playerChar.battleStatus.ability.name}」!</span>`);
                    log(`<span class="log-debuff">${opponentChar.name}의 공격이 하락했다!</span>`);
                    applyStatChange('opponent', 'attack', -1);
                }
                if (opponentChar.battleStatus.ability?.id === 'INTIMIDATE') {
                    log(`<span class="log-ability">${opponentChar.name}의 특성 「${opponentChar.battleStatus.ability.name}」!</span>`);
                    log(`<span class="log-debuff">${playerChar.name}의 공격이 하락했다!</span>`);
                    applyStatChange('player', 'attack', -1);
                }
            }

            async function battleLoop() {
                if (isBattleOver) return;

                if (playerChar.battleStatus.hp <= 0 || opponentChar.battleStatus.hp <= 0) {
                    isBattleOver = true;
                    cancelAnimationFrame(battleAnimationId); // Stop animation
                    window.removeEventListener('resize', onWindowResize);
                    const winner = playerChar.battleStatus.hp > 0 ? playerChar : opponentChar;
                    const loser = playerChar.battleStatus.hp <= 0 ? playerChar : opponentChar;
                    log(`<span class="log-win">🎉 ${winner.name}의 승리!</span>`);
                    playVictorySound();
                    const { rankChange, newWinnerRank, newLoserRank } = await updatePostBattleStats(winner, loser);

                    const winnerIndex = allCharacters.findIndex(c => c.id === winner.id);
                    if (winnerIndex > -1) allCharacters[winnerIndex].rank_points = newWinnerRank;
                    const loserIndex = allCharacters.findIndex(c => c.id === loser.id);
                    if (loserIndex > -1) allCharacters[loserIndex].rank_points = newLoserRank;

                    const winnerModalContent = `
                        <div class="text-center">
                            <h2 class="text-5xl font-bold text-yellow-400" style="text-shadow: 2px 2px #000;">WINNER</h2>
                            <img src="${winner.image_url}?width=256&quality=85" class="w-40 h-40 rounded-full object-cover mx-auto my-4 border-4 border-yellow-400 shadow-lg">
                            <p class="text-2xl font-bold">${winner.name}!</p>
                            <div class="mt-4 text-gray-300">
                                <p>${winner.name}: ${winner.rank_points || 1000} -> <span class="text-green-400 font-bold">${newWinnerRank} (+${rankChange})</span></p>
                                <p>${loser.name}: ${loser.rank_points || 1000} -> <span class="text-red-400 font-bold">${newLoserRank} (${newLoserRank - (loser.rank_points || 1000)})</span></p>
                            </div>
                            <button onclick="closeModal(); navigateTo('pokedex-view')" class="mt-6 w-full bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">메인으로</button>
                        </div>
                    `;
                    showModal('배틀 종료!', winnerModalContent);
                    return;
                }

                log(`<hr class="my-1 border-gray-500"><p class="log-turn">--- ${turn}턴 ---</p>`);
                
                const playerMoveIndex = Math.floor(Math.random() * playerChar.moves.length);
                const playerMove = playerChar.moves[playerMoveIndex];
                const opponentMoveIndex = Math.floor(Math.random() * opponentChar.moves.length);
                const opponentMove = opponentChar.moves[opponentMoveIndex];

                const playerMasterMove = MASTER_SKILL_LIST[playerMove.moveId];
                const opponentMasterMove = MASTER_SKILL_LIST[opponentMove.moveId];
                
                if (!playerMasterMove || !opponentMasterMove) {
                    cancelAnimationFrame(battleAnimationId);
                    window.removeEventListener('resize', onWindowResize);
                    showModal('배틀 오류', '<p>오래된 스킬 데이터를 가진 크리처가 있어 배틀을 진행할 수 없습니다.</p>');
                    navigateTo('pokedex-view');
                    return;
                }

                const playerPriority = playerMasterMove.priority || 0;
                const opponentPriority = opponentMasterMove.priority || 0;

                let firstAttacker;
                if (playerPriority !== opponentPriority) {
                    firstAttacker = playerPriority > opponentPriority ? 'player' : 'opponent';
                } else {
                    const playerSpeed = playerChar.stats.speed * getStatMultiplier(playerChar.battleStatus.stat_stages.speed);
                    const opponentSpeed = opponentChar.stats.speed * getStatMultiplier(opponentChar.battleStatus.stat_stages.speed);
                    firstAttacker = playerSpeed >= opponentSpeed ? 'player' : 'opponent';
                }
                
                const turnOrder = [
                    { type: firstAttacker, move: firstAttacker === 'player' ? playerMove : opponentMove, moveIndex: firstAttacker === 'player' ? playerMoveIndex : opponentMoveIndex },
                    { type: firstAttacker === 'player' ? 'opponent' : 'player', move: firstAttacker === 'player' ? opponentMove : playerMove, moveIndex: firstAttacker === 'player' ? opponentMoveIndex : playerMoveIndex }
                ];

                for (const turnAction of turnOrder) {
                    if (playerChar.battleStatus.hp > 0 && opponentChar.battleStatus.hp > 0) {
                        await processTurn(turnAction.type, turnAction.move, turnAction.moveIndex);
                    }
                }

                await processEndOfTurn();
                
                turn++;
                if (playerChar.battleStatus.hp > 0 && opponentChar.battleStatus.hp > 0) setTimeout(battleLoop, 2500);
                else setTimeout(battleLoop, 1000);
            }

            async function processTurn(attackerType, move, moveIndex) {
                 return new Promise(async (resolve) => {
                    const masterMove = MASTER_SKILL_LIST[move.moveId];

                    if (!masterMove) {
                        log(`<span class="log-debuff">${attackerType === 'player' ? playerChar.name : opponentChar.name}이(가) 알 수 없는 기술을 사용하려다 실패했다!</span>`);
                        return resolve();
                    }

                    const [attacker, defender] = attackerType === 'player' ? [playerChar, opponentChar] : [opponentChar, playerChar];
                    const [attackerSprite, defenderSprite] = attackerType === 'player' ? [playerSprite, opponentSprite] : [opponentSprite, playerSprite];
                    const defenderType = attackerType === 'player' ? 'opponent' : 'player';

                    if (attacker.battleStatus.status) {
                        if (attacker.battleStatus.status.type === 'sleep') {
                            if (Math.random() < 0.5) {
                                log(`<span class="log-status-sleep">${attacker.name}은(는) 깊은 잠에 빠져있다...</span>`);
                                return resolve();
                            } else {
                                log(`<span class="log-status-sleep">${attacker.name}이(가) 잠에서 깨어났다!</span>`);
                                attacker.battleStatus.status = null;
                                updateSpriteEffect(attackerSprite, null);
                            }
                        }
                        if (attacker.battleStatus.status && attacker.battleStatus.status.type === 'paralysis' && Math.random() < 0.25) {
                            log(`<span class="log-status-paralysis">${attacker.name}은(는) 몸이 저려 움직일 수 없다!</span>`);
                            return resolve();
                        }
                    }
                    
                    log(`${attacker.name}의 ${move.name} 공격!`);
                    document.getElementById(`${attackerType}-move-${moveIndex}`).classList.add('skill-use-animation');
                    
                    // Attack Animation
                    const originalPos = attackerSprite.position.clone();
                    const targetPos = defenderSprite.position.clone();
                    
                    gsap.to(attackerSprite.position, {
                        x: targetPos.x,
                        y: targetPos.y,
                        duration: 0.2,
                        yoyo: true,
                        repeat: 1,
                        onComplete: async () => {
                            // Hit Animation
                            gsap.to(defenderSprite.material, { opacity: 0.5, duration: 0.1, yoyo: true, repeat: 1 });
                            
                            const isDesperate = attacker.battleStatus.hp / attacker.stats.hp <= 0.25;
                            if (isDesperate) log(`<span class="log-desperate">${attacker.name}의 궁지(Desperate) 상태 발동!</span>`);

                            // Apply effects...
                            switch(masterMove.type) {
                                case 'damage':
                                    const { damage, isCritical, effectiveness } = calculateDamage(attacker, defender, move, isDesperate);
                                    defender.battleStatus.hp = Math.max(0, defender.battleStatus.hp - damage);
                                    logDamage(damage, isCritical, effectiveness);
                                    showDamageNumber(defenderSprite, damage, isCritical);
                                    if (masterMove.recoil) {
                                        const recoilDamage = Math.floor(damage * masterMove.recoil);
                                        attacker.battleStatus.hp = Math.max(0, attacker.battleStatus.hp - recoilDamage);
                                        log(`<span class="log-damage">${attacker.name}은(는) 반동 데미지를 ${recoilDamage} 입었다!</span>`);
                                        showDamageNumber(attackerSprite, recoilDamage, false);
                                    }
                                    if (masterMove.selfDebuff) {
                                        applyStatChange(attackerType, masterMove.selfDebuff.stat, masterMove.selfDebuff.amount);
                                        log(`<span class="log-debuff">${attacker.name}의 ${masterMove.selfDebuff.stat}이(가) 크게 하락했다!</span>`);
                                    }
                                    break;
                                case 'heal':
                                    const healAmount = Math.floor(attacker.stats.hp * masterMove.power);
                                    attacker.battleStatus.hp = Math.min(attacker.stats.hp, attacker.battleStatus.hp + healAmount);
                                    log(`<span class="log-heal">${attacker.name}은(는) HP를 ${healAmount} 회복했다!</span>`);
                                    break;
                                case 'buff':
                                    applyStatChange(attackerType, masterMove.stat, masterMove.amount);
                                    log(`<span class="log-buff">${attacker.name}의 ${masterMove.stat} 능력치가 상승했다!</span>`);
                                    break;
                                case 'debuff':
                                    applyStatChange(defenderType, masterMove.stat, masterMove.amount);
                                    log(`<span class="log-debuff">${defender.name}의 ${masterMove.stat} 능력치가 하락했다!</span>`);
                                    break;
                                case 'status':
                                    if (Math.random() < masterMove.chance && !defender.battleStatus.status) {
                                        defender.battleStatus.status = { type: masterMove.effect };
                                        log(`<span class="log-status-${masterMove.effect}">${defender.name}은(는) ${masterMove.effect} 상태가 되었다!</span>`);
                                        updateSpriteEffect(defenderSprite, masterMove.effect);
                                    }
                                    break;
                                case 'dot':
                                     defender.battleStatus.dots.push({ effect: masterMove.effect, damage: masterMove.damage, turns: masterMove.turns });
                                     log(`<span class="log-status-${masterMove.effect}">${defender.name}은(는) 지속 데미지를 입기 시작했다!</span>`);
                                     updateSpriteEffect(defenderSprite, masterMove.effect);
                                     break;
                                case 'shield':
                                     attacker.battleStatus.shield += Math.floor(attacker.stats.hp * masterMove.amount);
                                     log(`<span class="log-shield">${attacker.name}에게 보호막이 생겼다!</span>`);
                                     break;
                            }
                            updateHPBars();
                            
                            document.getElementById(`${attackerType}-move-${moveIndex}`).classList.remove('skill-use-animation');
                            
                            setTimeout(resolve, 500);
                        }
                    });
                });
            }

            async function processEndOfTurn() {
                for (const charData of [{char: playerChar, type: 'player', sprite: playerSprite}, {char: opponentChar, type: 'opponent', sprite: opponentSprite}]) {
                    if (charData.char.battleStatus.hp <= 0) continue;
                    if (charData.char.battleStatus.ability?.id === 'SPEED_BOOST') {
                        log(`<span class="log-ability">${charData.char.name}의 특성 「${charData.char.battleStatus.ability.name}」!</span>`);
                        applyStatChange(charData.type, 'speed', 1);
                        log(`<span class="log-buff">${charData.char.name}의 속도가 상승했다!</span>`);
                    }
                    if (charData.char.battleStatus.ability?.id === 'REGENERATOR') {
                        const healAmount = Math.floor(charData.char.stats.hp / 16);
                        charData.char.battleStatus.hp = Math.min(charData.char.stats.hp, charData.char.battleStatus.hp + healAmount);
                        log(`<span class="log-ability">${charData.char.name}의 특성 「${charData.char.battleStatus.ability.name}」!</span>`);
                        log(`<span class="log-heal">${charData.char.name}은(는) HP를 ${healAmount} 회복했다.</span>`);
                    }
                    charData.char.battleStatus.dots.forEach(dot => {
                        const dotDamage = Math.floor(charData.char.stats.hp * dot.damage);
                        charData.char.battleStatus.hp = Math.max(0, charData.char.battleStatus.hp - dotDamage);
                        log(`<span class="log-status-${dot.effect}">${charData.char.name}은(는) ${dot.effect} 데미지로 ${dotDamage}의 피해를 입었다.</span>`);
                    });
                    const decrement = (effect) => { effect.turns--; return effect.turns > 0; };
                    charData.char.battleStatus.dots = charData.char.battleStatus.dots.filter(decrement);
                    
                    // Update sprite effect if DoT expires
                    if (!charData.char.battleStatus.dots.some(d => d.effect === 'poison')) {
                        updateSpriteEffect(charData.sprite, charData.char.battleStatus.status?.type);
                    }
                }
                updateHPBars();
            }
            
            function updateSpriteEffect(sprite, effect) {
                if (!sprite) return;
                // Reset color first
                sprite.material.color.setHex(0xffffff);

                switch(effect) {
                    case 'poison':
                        sprite.material.color.setHex(0xab47bc); // Purple tint
                        break;
                    case 'sleep':
                        sprite.material.color.setHex(0x888888); // Gray tint
                        break;
                    // Paralysis is an animation, handled in main animate loop if needed
                    default:
                        // No color change
                        break;
                }
            }
            
            function applyStatChange(targetType, stat, stages) {
                const target = targetType === 'player' ? playerChar : opponentChar;
                const statKeys = stat === 'all' ? ['attack', 'defense', 'sp_atk', 'sp_def', 'speed'] : [stat];
                statKeys.forEach(sKey => {
                    target.battleStatus.stat_stages[sKey] = Math.max(-6, Math.min(6, target.battleStatus.stat_stages[sKey] + stages));
                });
            }

            function logDamage(damage, isCritical, effectiveness) {
                let damageLog = `<span class="log-damage">${damage}의 데미지를 입혔다.</span>`;
                if (isCritical) { 
                    damageLog += ` <span class="log-crit">급소에 맞았다!</span>`; 
                    playCritSound();
                    showBattleEffect('CRITICAL HIT!', 'crit');
                }
                if (effectiveness > 1) { 
                    damageLog += ` <span class="log-super-effective">효과가 굉장했다!</span>`; 
                    playSuperEffectiveSound();
                    showBattleEffect('SUPER EFFECTIVE!', 'super-effective');
                }
                if (effectiveness < 1 && effectiveness > 0) damageLog += ` <span class="log-not-effective">효과가 별로인 듯하다...</span>`;
                if (effectiveness === 0) damageLog += ` <span class="log-no-effect">효과가 없는 것 같다...</span>`;
                log(damageLog);
            }

            function updateHPBars() {
                const playerHPRatio = playerChar.battleStatus.hp / playerChar.stats.hp;
                const opponentHPRatio = opponentChar.battleStatus.hp / opponentChar.stats.hp;
                const playerHPBar = document.getElementById('player-hp-bar');
                const opponentHPBar = document.getElementById('opponent-hp-bar');
                if(playerHPBar) {
                    playerHPBar.style.width = `${playerHPRatio * 100}%`;
                    playerHPBar.style.backgroundColor = playerHPRatio > 0.5 ? '#22c55e' : playerHPRatio > 0.2 ? '#facc15' : '#ef4444';
                    document.getElementById('player-hp-text').textContent = `${Math.ceil(playerChar.battleStatus.hp)} / ${playerChar.stats.hp}`;
                }
                if(opponentHPBar) {
                    opponentHPBar.style.width = `${opponentHPRatio * 100}%`;
                    opponentHPBar.style.backgroundColor = opponentHPRatio > 0.5 ? '#22c55e' : opponentHPRatio > 0.2 ? '#facc15' : '#ef4444';
                    document.getElementById('opponent-hp-text').textContent = `${Math.ceil(opponentChar.battleStatus.hp)} / ${opponentChar.stats.hp}`;
                }
            }
            
            function showDamageNumber(targetSprite, damage, isCritical) {
                const damageDiv = document.createElement('div');
                damageDiv.textContent = damage;
                damageDiv.className = `damage-number ${isCritical ? 'crit' : ''}`;
                battleEffectsContainer.appendChild(damageDiv);

                const vector = new THREE.Vector3();
                targetSprite.updateWorldMatrix(true, false);
                vector.setFromMatrixPosition(targetSprite.matrixWorld);
                vector.project(camera);

                const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight;

                gsap.fromTo(damageDiv, 
                    { x: x, y: y, opacity: 1, scale: 0 },
                    { x: x, y: y - 50, opacity: 0, scale: 1.5, duration: 1.5, ease: "power1.out", onComplete: () => damageDiv.remove() }
                );
            }

            // Add event listeners for skill modals
            document.querySelectorAll('.battle-move-item').forEach(el => {
                el.addEventListener('click', () => {
                    const moveId = el.dataset.moveId;
                    const masterMove = MASTER_SKILL_LIST[moveId];
                    if (masterMove) {
                        const content = `
                            <p class="text-gray-400">${masterMove.text}</p>
                            <div class="text-sm mt-2">
                                ${masterMove.power ? `<span><b>위력:</b> ${masterMove.power}</span>` : ''}
                                ${masterMove.category ? `<span class="ml-4"><b>분류:</b> ${masterMove.category}</span>` : ''}
                            </div>
                        `;
                        showModal(`스킬 정보: ${el.textContent}`, content);
                    }
                });
            });

            applyStartOfBattleAbilities();
            setTimeout(battleLoop, 2000);
        };
        
        window.renderRankingView = async function() {
            rankingViewContainer.innerHTML = '';
            const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .order('rank_points', { ascending: false });

            if (error) {
                rankingViewContainer.innerHTML = `<p class="text-center p-8">랭킹을 불러오는 데 실패했습니다.</p>`;
                return;
            }

            const sorted = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile }));

            rankingViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <h2 class="font-title text-4xl text-center mb-8">전체 랭킹</h2>
                    <div class="bg-gray-800 rounded-lg shadow-lg">
                        <ul id="ranking-list" class="divide-y divide-gray-700">
                            ${sorted.map((char, index) => `
                                <li class="p-4 flex items-center justify-between hover:bg-gray-700/50 cursor-pointer" onclick="navigateTo('detail-view', ${char.id})">
                                    <div class="flex items-center gap-4">
                                        <span class="text-lg font-bold w-8 text-center text-gray-400">${index + 1}</span>
                                        <img src="${char.image_url}?width=64&quality=80" class="w-12 h-12 rounded-full object-cover" loading="lazy">
                                        <div>
                                            <p class="font-bold text-white">${char.name}</p>
                                            <p class="text-sm text-gray-400">${char.rarity} / by ${char.profile?.nickname || char.profile?.email?.split('@')[0]}</p>
                                        </div>
                                    </div>
                                    <div class="font-bold text-lg text-yellow-400">${char.rank_points || 1000} RP</div>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                </div>
            `;
        };

        window.renderProfileView = async function(profileId) {
            const profile = allProfiles.find(p => p.id === profileId);
            if (!profile) { profileViewContainer.innerHTML = `<p class="text-center p-8">프로필을 찾을 수 없습니다.</p>`; return; }
            
            const userCharacters = allCharacters.filter(c => c.creator_id === profileId).sort((a, b) => (b.rank_points || 1000) - (a.rank_points || 1000));
            const isMyProfile = currentUser?.id === profileId;

            profileViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md mb-6">
                        <h2 class="text-2xl font-bold">프로필 정보</h2>
                        <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><span class="font-semibold">이메일:</span> ${profile.email}</div>
                            <div class="flex items-center gap-2"><span class="font-semibold">닉네임:</span> <span id="nickname-display">${profile.nickname || '미설정'}</span> ${isMyProfile ? `<button id="edit-nickname-btn" class="text-sm text-[#8abeb7]">변경</button>` : ''}</div>
                            <div id="nickname-edit-form" class="hidden"><input type="text" id="nickname-input" value="${profile.nickname || ''}" class="p-1 border rounded bg-gray-700 border-gray-600"><button id="save-nickname-btn" class="ml-2 bg-green-500 text-white px-2 py-1 rounded">저장</button></div>
                            <div><span class="font-semibold">보유 크레딧:</span> ${isMyProfile ? currentProfile.credits : '비공개'}</div>
                            ${isMyProfile ? `<button id="check-in-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full md:w-auto">출석 체크 (1 크레딧 획득)</button>` : ''}
                        </div>
                    </div>
                    <h2 class="text-2xl font-bold mb-4">생성한 캐릭터 목록 (${userCharacters.length}개)</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        ${userCharacters.length > 0 ? userCharacters.map(char => `<div class="pokedex-card p-4" onclick="navigateTo('detail-view', ${char.id})"><h3 class="font-bold">${char.name}</h3><img src="${char.image_url}?width=320&quality=80" class="w-full h-32 object-cover rounded my-2" loading="lazy"><p>랭킹: #${allCharacters.sort((a,b) => (b.rank_points||1000)-(a.rank_points||1000)).findIndex(c=>c.id===char.id)+1} (${char.rank_points || 1000} RP)</p></div>`).join('') : '<p>아직 생성한 캐릭터가 없습니다.</p>'}
                    </div>
                </div>
            `;

            if (isMyProfile) {
                document.getElementById('edit-nickname-btn').onclick = () => {
                    document.getElementById('nickname-display').classList.add('hidden');
                    document.getElementById('edit-nickname-btn').classList.add('hidden');
                    document.getElementById('nickname-edit-form').classList.remove('hidden');
                };
                document.getElementById('save-nickname-btn').onclick = async () => {
                    const newNickname = document.getElementById('nickname-input').value.trim();
                    if (newNickname) {
                        const { error } = await supabaseClient.from('battle_profiles').update({ nickname: newNickname }).eq('id', currentUser.id);
                        if (error) { showModal('오류', `<p>닉네임 변경 실패: ${error.message}</p>`); }
                        else {
                            document.getElementById('nickname-display').textContent = newNickname;
                            document.getElementById('nickname-display').classList.remove('hidden');
                            document.getElementById('edit-nickname-btn').classList.remove('hidden');
                            document.getElementById('nickname-edit-form').classList.add('hidden');
                        }
                    }
                };
                document.getElementById('check-in-btn').onclick = async () => {
                    const today = new Date().toISOString().split('T')[0];
                    if (currentProfile.last_check_in === today) {
                        showModal('출석 체크', '<p>오늘은 이미 출석했습니다.</p>');
                        return;
                    }
                    if(currentProfile.credits >= 5) {
                        showModal('크레딧 최대', '<p>무료 크레딧은 최대 5개까지 보유할 수 있습니다.</p>');
                        return;
                    }
                    const newCredits = currentProfile.credits + 1;
                    const { error } = await supabaseClient.from('battle_profiles').update({ credits: newCredits, last_check_in: today }).eq('id', currentUser.id);
                    if (error) { showModal('오류', `<p>출석 체크 실패: ${error.message}</p>`); }
                    else { showModal('출석 완료!', '<p>1 크레딧을 획득했습니다!</p>'); }
                };
            }
        };

        window.renderAdminView = function() {
            if (!currentProfile?.is_admin) { navigateTo('pokedex-view'); return; }
            adminViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <h2 class="font-title text-4xl text-center mb-8">관리자 페이지</h2>
                    <div class="bg-gray-800 rounded-lg shadow-lg p-6">
                        <h3 class="font-bold text-xl mb-4">사용자 목록</h3>
                        <div class="divide-y divide-gray-700">
                            ${allProfiles.map(p => `
                                <div class="py-3 flex justify-between items-center">
                                    <div><p class="font-semibold">${p.nickname || '미설정'}</p><p class="text-sm text-gray-400">${p.email}</p></div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-20">크레딧: ${p.credits}</span>
                                        <input type="number" id="credit-input-${p.id}" class="w-20 p-1 border rounded bg-gray-700 border-gray-600" value="${p.credits}">
                                        <button data-id="${p.id}" class="save-credit-btn bg-blue-500 text-white px-3 py-1 rounded">저장</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.querySelectorAll('.save-credit-btn').forEach(btn => {
                btn.onclick = async () => {
                    const userId = btn.dataset.id;
                    const newCredits = document.getElementById(`credit-input-${userId}`).value;
                    const { error } = await supabaseClient.from('battle_profiles').update({ credits: parseInt(newCredits) }).eq('id', userId);
                    if (error) { showModal('오류', `<p>크레딧 수정 실패: ${error.message}</p>`); }
                    else { showModal('성공', '<p>크레딧이 성공적으로 수정되었습니다.</p>'); }
                };
            });
        };
        
        window.renderRankingPodium = async function() {
            const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .order('rank_points', { ascending: false })
                .limit(3);

            if (error) { console.error('Error fetching podium data:', error); return; }

            const top3 = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile }));
            
            rankingPodiumView.innerHTML = top3.map((char, index) => {
                const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
                const imageUrl = `${char.image_url}?width=256&quality=85`;
                return `
                <div class="podium-item podium-${index + 1}">
                    <p class="text-2xl font-bold mb-2">${index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉'}</p>
                    <img src="${imageUrl}" class="podium-img" onclick="navigateTo('detail-view', ${char.id})">
                    <div class="podium-base flex flex-col justify-center items-center p-2">
                        <p class="text-lg font-bold">${char.name}</p>
                        <p class="text-sm">${char.rank_points || 1000} RP</p>
                        <p class="text-xs mt-1">by <a href="#" onclick="event.stopPropagation(); navigateTo('profile-view', '${char.creator_id}')" class="hover:underline">${creatorName}</a></p>
                    </div>
                </div>
            `}).join('');
            if (top3.length === 0) {
                rankingPodiumView.innerHTML = `<p class="text-center text-gray-500 col-span-full">아직 랭킹 데이터가 없습니다.</p>`;
            }
        };

        function getRankBadge(rank) {
            if (!rank || rank > 100) return '<div class="rank-badge badge-wood"><span>전적 없음</span></div>';
            if (rank <= 3) return '<div class="rank-badge badge-gold"><span>🏆 Top 3</span></div>';
            if (rank <= 10) return '<div class="rank-badge badge-silver"><span>🥈 Top 10</span></div>';
            if (rank <= 20) return '<div class="rank-badge badge-bronze"><span>🥉 Top 20</span></div>';
            if (rank <= 30) return '<div class="rank-badge badge-iron"><span>Top 30</span></div>';
            if (rank <= 50) return '<div class="rank-badge badge-stone"><span>Top 50</span></div>';
            if (rank <= 100) return '<div class="rank-badge badge-wood"><span>Top 100</span></div>';
            return '<div class="rank-badge badge-wood"><span>전적 없음</span></div>';
        }
        
        function showBattleEffect(text, type) {
            const effect = document.createElement('div');
            effect.className = `impact-text ${type} text-5xl sm:text-7xl lg:text-8xl`;
            effect.textContent = text;
            battleEffectsContainer.appendChild(effect);
            
            // Apply screen shake to the battle arena view
            battleArenaContainer.classList.add('screen-shake');
            setTimeout(() => {
                battleArenaContainer.classList.remove('screen-shake');
            }, 300);


            setTimeout(() => {
                effect.remove();
            }, 1000);
        }

        // --- Pokedex Background Animation ---
        function initPokedexBackground() {
            if (pokedexAnimationId) return; // Already running

            const canvas = document.getElementById('pokedex-bg-canvas');
            if (!canvas) return;
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 700, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
            
            renderer.setSize(window.innerWidth, 700);
            camera.position.z = 1;

            const particlesGeometry = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            const color1 = new THREE.Color(0x6A0DAD); // Purple
            const color2 = new THREE.Color(0x0077BE); // Blue

            for(let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;

                const mixedColor = Math.random() > 0.5 ? color1 : color2;
                colors[i * 3] = mixedColor.r;
                colors[i * 3 + 1] = mixedColor.g;
                colors[i * 3 + 2] = mixedColor.b;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.02,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.9,
                vertexColors: true
            });
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);

            const clock = new THREE.Clock();

            const animate = () => {
                const elapsedTime = clock.getElapsedTime();
                particles.position.z = (elapsedTime * 0.5) % 5;
                
                renderer.render(scene, camera);
                pokedexAnimationId = window.requestAnimationFrame(animate);
            };
            animate();

            window.addEventListener('resize', () => {
                const container = document.getElementById('pokedex-view-background');
                const newHeight = container.clientHeight;
                renderer.setSize(window.innerWidth, newHeight);
                camera.aspect = window.innerWidth / newHeight;
                camera.updateProjectionMatrix();
            });
        }


        // --- Initial Load & Event Listeners ---
        document.addEventListener('DOMContentLoaded', async () => {
            const { data: { session } } = await supabaseClient.auth.getSession();
            currentUser = session?.user || null;
            await initialDataLoad();
            listenToAuthStateChanges();
            subscribeToChanges();
            document.body.addEventListener('click', setupAudio, { once: true });
        });
        
        homeBtn.addEventListener('click', () => navigateTo('pokedex-view'));
        generateBtn.addEventListener('click', generateCharacter);
        promptInput.addEventListener('keydown', e => e.key === 'Enter' && generateCharacter());
        goToBattleBtn.addEventListener('click', () => navigateTo('battle-selection-view'));
        goToRankingBtn.addEventListener('click', () => navigateTo('ranking-view'));
        showTypeChartBtn.addEventListener('click', showTypeChartModal);
        showRarityTableBtn.addEventListener('click', showRarityModal);
        loginForm.addEventListener('submit', handleLogin);
        signupForm.addEventListener('submit', handleSignup);
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                playUiClickSound();
                const tab = btn.dataset.tab;
                document.querySelectorAll('.auth-form').forEach(form => form.classList.add('hidden'));
                document.getElementById(`${tab}-form`).classList.remove('hidden');
                tabBtns.forEach(b => {
                    b.classList.remove('border-blue-500', 'text-blue-500');
                    b.classList.add('text-gray-500', 'border-transparent');
                });
                btn.classList.remove('text-gray-500', 'border-transparent');
                btn.classList.add('border-blue-500', 'text-blue-500');
            });
        });
        tabBtns[0].click();
        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                playUiClickSound();
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                activeFilter = btn.dataset.filter;
                // Reset and load for the new filter
                allCharacters = [];
                currentPage = 0;
                loadMoreCharacters();
            });
        });
    </script>
</body>
</html>
