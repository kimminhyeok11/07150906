<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>몬배틀 헌터즈 (MonBattle Hunters)</title>
    <!-- Tailwind CSS, Tone.js, Supabase, anime.js -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-mid: #16213e;
            --bg-light: #0f3460;
            --primary: #e94560;
            --secondary: #533483;
            --accent: #ffc107;
            --text-light: #e0e0e0;
            --text-dark: #1a1a2e;
        }

        /* Base Styles */
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-dark); color: var(--text-light); overflow-x: hidden; }
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .font-title { font-family: 'Black Han Sans', sans-serif; }

        /* Card Styles */
        .pokedex-card { 
            background: linear-gradient(145deg, #2a2a3a, #1a1a2a); 
            border-left-width: 6px; 
            transition: all 0.3s ease-in-out; 
            cursor: pointer; 
            position: relative; 
            overflow: hidden; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .pokedex-card:hover { 
            transform: translateY(-8px) scale(1.03); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
        }
        .stat-bar-bg { background-color: #16213e; border-radius: 999px;}
        .stat-bar { background: linear-gradient(90deg, var(--secondary), var(--primary)); border-radius: 999px; }
        
        .level-display {
            position: absolute; top: 8px; right: 8px; background: linear-gradient(45deg, var(--accent), #f9a825);
            color: var(--text-dark); padding: 3px 10px; border-radius: 16px;
            font-size: 0.8rem; font-weight: 900; z-index: 2; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .streak-display {
            position: absolute; top: 8px; left: 8px;
            background: linear-gradient(45deg, #e94560, #ff6b81);
            color: white; padding: 2px 8px; border-radius: 16px;
            font-size: 0.7rem; font-weight: bold; z-index: 2;
        }
        .rank-display {
            position: absolute; bottom: 8px; right: 8px; background: rgba(0,0,0,0.6);
            color: var(--accent); padding: 3px 10px; border-radius: 16px;
            font-size: 0.75rem; font-weight: 700; z-index: 2;
        }

        /* Type & Universe Badges */
        .type-badge { padding: 4px 12px; border-radius: 12px; font-weight: 700; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .type-Normal { background-color: #A8A77A; } .type-Fire { background-color: #EE8130; }
        .type-Water { background-color: #6390F0; } .type-Electric { background-color: #F7D02C; }
        .type-Grass { background-color: #7AC74C; } .type-Ice { background-color: #96D9D6; }
        .type-Fighting { background-color: #C22E28; } .type-Poison { background-color: #A33EA1; }
        .type-Ground { background-color: #E2BF65; } .type-Flying { background-color: #A98FF3; }
        .type-Psychic { background-color: #F95587; } .type-Bug { background-color: #A6B91A; }
        .type-Rock { background-color: #B6A136; } .type-Ghost { background-color: #735797; }
        .type-Dragon { background-color: #6F35FC; } .type-Darkness { background-color: #705746; }
        .type-Steel { background-color: #B7B7CE; } .type-Fairy { background-color: #D685AD; }
        .type-Light { background: linear-gradient(45deg, #FFFDE4, #F9E79F); color: #B48A00; text-shadow: 0 0 2px white; }

        /* Rarity Styles & Card Border Glows */
        .rarity-badge { padding: 4px 12px; border-radius: 12px; font-weight: 900; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .rarity-일반 { background-color: #B0BEC5; } .rarity-희귀 { background-color: #42A5F5; }
        .rarity-에픽 { background-color: #AB47BC; } .rarity-전설 { background: linear-gradient(45deg, #FFEE58, #F57F17); text-shadow: 0 0 2px black; }
        .rarity-고대 { background: linear-gradient(45deg, #4DB6AC, #004D40); text-shadow: 0 0 2px black; }
        .rarity-신화 { background: linear-gradient(45deg, #FF7043, #D84315, #BF360C); text-shadow: 0 0 2px black; }
        
        .card-border-일반 { border-color: #B0BEC5; } .card-border-희귀 { border-color: #42A5F5; }
        .card-border-에픽 { border-color: #AB47BC; } .card-border-전설 { border-color: #F57F17; }
        .card-border-고대 { border-color: #004D40; } .card-border-신화 { border-color: #BF360C; }
        .pokedex-card:hover.card-border-희귀 { box-shadow: 0 10px 30px rgba(66, 165, 245, 0.3); }
        .pokedex-card:hover.card-border-에픽 { box-shadow: 0 10px 30px rgba(171, 71, 188, 0.3); }
        .pokedex-card:hover.card-border-전설 { box-shadow: 0 10px 30px rgba(245, 127, 23, 0.4); }
        .pokedex-card:hover.card-border-고대 { box-shadow: 0 10px 30px rgba(0, 77, 64, 0.4); }
        .pokedex-card:hover.card-border-신화 { box-shadow: 0 10px 30px rgba(191, 54, 12, 0.5); }

        /* Ranking Podium Styles */
        .podium { display: flex; justify-content: center; align-items: flex-end; gap: 1rem; min-height: 280px; }
        .podium-item { text-align: center; width: 30%; max-width: 150px; cursor: pointer; transition: transform 0.3s ease; display: flex; flex-direction: column; align-items: center; }
        .podium-item:hover { transform: scale(1.05); }
        .podium-img { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; margin: 0 auto; border: 4px solid; margin-bottom: -40px; z-index: 1; transition: all 0.3s ease; }
        .podium-item:hover .podium-img { box-shadow: 0 0 15px var(--border-color); }
        .podium-base { color: white; padding-top: 45px; border-radius: 8px; width: 100%; box-shadow: inset 0 4px 10px rgba(0,0,0,0.4); padding-bottom: 0.5rem; transition: background 0.3s ease; }
        .podium-1 { order: 2; --border-color: #FFD700; } .podium-1 .podium-base { min-height: 150px; background: linear-gradient(45deg, #FFD700, #F5B000); color: #333; } .podium-1 .podium-img { border-color: #FFD700; width: 100px; height: 100px; margin-bottom:-50px; }
        .podium-2 { order: 1; --border-color: #C0C0C0; } .podium-2 .podium-base { min-height: 120px; background: linear-gradient(45deg, #C0C0C0, #A9A9A9); color: #333; } .podium-2 .podium-img { border-color: #C0C0C0; }
        .podium-3 { order: 3; --border-color: #CD7F32; } .podium-3 .podium-base { min-height: 100px; background: linear-gradient(45deg, #CD7F32, #A0522D); color: #fff; } .podium-3 .podium-img { border-color: #CD7F32; }

        /* Battle Arena Styles */
        #battle-arena-view { background-color: black; }
        #battle-background { transition: filter 0.5s ease, transform 20s ease-in-out; transform: scale(1.1); }
        .battle-ui-overlay { backdrop-filter: blur(2px); }
        .battle-character-ui {
            background-color: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(129, 140, 248, 0.3);
            backdrop-filter: blur(8px);
            clip-path: polygon(0 0, 100% 0, 100% 100%, 15% 100%, 0 75%);
            transition: all 0.3s ease;
        }
        .hp-bar-bg { background-color: rgba(0,0,0,0.5); border: 1px solid #334155; }
        .hp-bar-inner { background: linear-gradient(90deg, #4ade80, #16a34a); transition: width 0.5s ease-in-out; }
        .battle-character-sprite {
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
            animation: breathing 3s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        @keyframes breathing { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
        @keyframes shake { 0%,100%{transform:translateX(0)} 20%,60%{transform:translateX(-5px)} 40%,80%{transform:translateX(5px)} }
        .shake-anim { animation: shake 0.5s ease-in-out; }
        .attack-lunge-anim { animation: attack-lunge 0.4s ease-in-out; }
        @keyframes attack-lunge { 0% { transform: translate(0, 0); } 50% { transform: translate(-30px, 10px) scale(1.1); } 100% { transform: translate(0, 0); } }
        .attack-lunge-anim-enemy { animation: attack-lunge-enemy 0.4s ease-in-out; }
        @keyframes attack-lunge-enemy { 0% { transform: translate(0, 0); } 50% { transform: translate(30px, 10px) scale(1.1); } 100% { transform: translate(0, 0); } }
        .screen-shake-crit { animation: screen-shake 0.3s ease-in-out; }
        @keyframes screen-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
        }
        .damage-indicator {
            position: absolute;
            font-size: 2rem; /* Mobile first font size */
            font-weight: 900;
            color: white;
            -webkit-text-stroke: 1px black;
            animation: damage-pop 1s ease-out forwards;
            pointer-events: none;
        }
        .damage-indicator.critical {
            color: var(--primary);
            font-size: 2.5rem; /* Mobile first font size */
             -webkit-text-stroke: 2px white;
        }
        @keyframes damage-pop {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-60px) scale(1.3); opacity: 0; }
        }
        /* Desktop sizes for damage indicator */
        @media (min-width: 768px) {
            .damage-indicator {
                font-size: 2.5rem;
                -webkit-text-stroke: 2px black;
            }
            .damage-indicator.critical {
                font-size: 3.5rem;
            }
        }


        #battle-controls {
            background-color: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(129, 140, 248, 0.3);
            backdrop-filter: blur(8px);
        }
        .battle-move-item { border-color: #334155; transition: all 0.2s ease; }
        .battle-move-item:hover:not(:disabled) { background-color: var(--bg-light); border-color: var(--primary);}
        
        /* Modal, Tooltip, Filters */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 10000; backdrop-filter: blur(5px); }
        .modal-content { animation: fadeIn 0.3s; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        #move-tooltip { position: fixed; background: #1e293b; color: #cbd5e1; padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid #334155; z-index: 10002; pointer-events: none; opacity: 0; transition: opacity 0.2s; font-size: 0.875rem; }
        .filter-btn { padding: 0.5rem 1rem; border-radius: 999px; font-weight: bold; background-color: #334155; color: #94a3b8; transition: all 0.2s ease; }
        .filter-btn.active { background-color: var(--primary); color: white; }

        /* Inventory & Manual Styles */
        .inventory-item { background: linear-gradient(145deg, #2a2a3a, #1a1a2a); transition: transform 0.2s ease; }
        .inventory-item:hover { transform: scale(1.05); }
        .inventory-item-image {
            width: 64px; height: 64px; margin: 0 auto 0.5rem;
            background: radial-gradient(circle, #334155 0%, #1e293b 100%);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 2rem; color: #64748b;
        }
        #manual-view h3 { font-size: 1.5rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; border-bottom: 1px solid #515151; padding-bottom: 0.5rem; color: var(--primary); }
        #manual-view p { margin-bottom: 1rem; line-height: 1.7; color: var(--text-light); }

        /* Toggle Switch */
        .toggle-checkbox:checked { right: 0; border-color: var(--primary); }
        .toggle-checkbox:checked + .toggle-label { background-color: var(--primary); }
        .toggle-checkbox {
            right: auto;
            left: 0;
            transition: all 0.2s ease-in-out;
        }
        .toggle-checkbox:checked {
            left: auto;
            right: 0;
        }

        .status-icon {
            position: absolute;
            left: 8px;
            bottom: 8px;
            width: 24px;
            height: 24px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 3;
        }

    </style>
</head>
<body class="bg-slate-900 text-slate-300">
    <!-- Overlays and Loaders -->
    <div id="modal-container"></div>
    <div id="move-tooltip"></div>
    <div id="toast-container" class="fixed bottom-5 right-5 z-[10001] space-y-2"></div>

    <!-- Navigation Bar -->
    <nav class="bg-slate-900/80 backdrop-blur-sm shadow-lg sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <span class="font-title text-xl sm:text-2xl text-cyan-400 cursor-pointer" id="home-btn">몬배틀 헌터즈</span>
                </div>
                <div id="nav-links" class="flex items-center gap-1 sm:gap-4"></div>
            </div>
        </div>
    </nav>

    <!-- Auth View -->
    <div id="auth-view" class="view">
        <div class="max-w-md mx-auto mt-10 p-6 sm:p-8 bg-slate-800 rounded-lg shadow-lg">
            <div id="auth-tabs" class="flex border-b border-slate-700 mb-6">
                <button data-tab="login" class="tab-btn flex-1 py-2 font-bold text-gray-500 border-b-2 border-transparent">로그인</button>
                <button data-tab="signup" class="tab-btn flex-1 py-2 font-bold text-gray-500 border-b-2 border-transparent">회원가입</button>
            </div>
            <form id="login-form" class="auth-form space-y-4">
                <input type="email" id="login-email" placeholder="이메일" class="w-full p-3 border rounded-lg bg-slate-700 text-white border-slate-600" required>
                <div class="relative">
                    <input type="password" id="login-password" placeholder="비밀번호" class="w-full p-3 pr-10 border rounded-lg bg-slate-700 text-white border-slate-600" required>
                    <button type="button" id="toggle-password-visibility" class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white">
                        <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.022 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                        </svg>
                        <svg id="eye-slash-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" viewBox="0 0 20 20" fill="currentColor">
                           <path fill-rule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z" clip-rule="evenodd" />
                           <path d="M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.742L2.303 6.546A10.048 10.048 0 01.458 10c1.274 4.057 5.022 7 9.542 7 1.655 0 3.21-.393 4.6-1.093l-1.646-1.646z" />
                        </svg>
                    </button>
                </div>
                <button type="submit" class="w-full bg-sky-600 text-white font-bold py-3 rounded-lg hover:bg-sky-500">로그인</button>
                <a href="#" id="forgot-password-link" class="text-sm text-sky-400 hover:underline text-center block mt-2">비밀번호를 잊으셨나요?</a>
            </form>
            <form id="signup-form" class="auth-form space-y-4 hidden">
                <input type="email" id="signup-email" placeholder="이메일" class="w-full p-3 border rounded-lg bg-slate-700 text-white border-slate-600" required>
                <input type="password" id="signup-password" placeholder="비밀번호" class="w-full p-3 border rounded-lg bg-slate-700 text-white border-slate-600" required>
                <button type="submit" class="w-full bg-teal-500 text-white font-bold py-3 rounded-lg hover:bg-teal-400">회원가입 (5 크레딧 지급)</button>
            </form>
            <p id="auth-error" class="text-red-400 text-center mt-4"></p>
        </div>
    </div>
    
    <div id="pokedex-view" class="view">
        <div class="max-w-7xl mx-auto p-2 sm:p-4">
             <div id="main-header-background" class="relative bg-gradient-to-br from-slate-800 to-slate-900 rounded-2xl shadow-lg overflow-hidden mb-6">
                <header class="text-center py-8 sm:py-12 px-4">
                    <h1 class="font-title text-3xl sm:text-4xl md:text-5xl text-gray-100 drop-shadow-lg">몬배틀 헌터즈</h1>
                    <p class="text-gray-300 mt-1 text-xs sm:text-sm">우주 최강의 종족을 가리는 갤럭시 토너먼트!</p>
                    <div class="mt-4 flex justify-center flex-wrap gap-2">
                        <button id="go-to-battle-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-500 transition-transform transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed text-sm shadow-md">배틀 아레나</button>
                        <button id="go-to-ranking-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-400 transition-transform transform hover:scale-105 text-sm shadow-md">랭킹 보기</button>
                        <button id="show-manual-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-500 transition-transform transform hover:scale-105 text-sm shadow-md">게임 방법</button>
                        <button id="show-rarity-table-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-500 transition-transform transform hover:scale-105 text-sm shadow-md">등급표</button>
                        <button id="show-type-chart-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-500 transition-transform transform hover:scale-105 text-sm shadow-md">상성표</button>
                    </div>
                </header>
                <div id="ranking-podium-container" class="pb-12 px-4">
                    <h2 class="font-title text-2xl text-center mb-6 text-gray-200">명예의 전당</h2>
                    <div id="ranking-podium-view" class="podium"></div>
                </div>
            </div>

            <div id="character-creation-section" class="bg-slate-800/80 backdrop-blur-sm p-4 rounded-2xl shadow-lg mb-4">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                    <select id="universe-select" class="p-2 border-2 rounded-lg focus:outline-none focus:ring-2 bg-slate-700 text-white border-slate-600 focus:ring-sky-500 text-sm sm:text-base">
                        <option value="에테리얼">에테리얼 (에너지 종족)</option>
                        <option value="키티노이드">키티노이드 (곤충 종족)</option>
                        <option value="어비셜">어비셜 (심연 종족)</option>
                    </select>
                    <input type="text" id="character-prompt" class="md:col-span-2 p-2 border-2 rounded-lg focus:outline-none focus:ring-2 bg-slate-700 text-white border-slate-600 focus:ring-teal-400 text-sm sm:text-base" placeholder="예: 불타는 날개를 가진, 수정 갑옷을 입은">
                </div>
                <div class="mt-3 flex justify-center items-center gap-4">
                    <button id="generate-btn" class="bg-teal-500 text-white font-bold py-2 px-5 rounded-lg hover:bg-teal-400 transition-transform transform hover:scale-105 shadow-lg">
                        <span id="btn-text">크리처 소환! (1 크레딧)</span>
                    </button>
                </div>
                <div id="error-message" class="text-yellow-400 mt-2 text-center text-sm font-semibold"></div>
            </div>
             <div id="filter-container" class="flex justify-center gap-2 mb-4">
                  <button class="filter-btn active" data-filter="all">전체</button>
                  <button class="filter-btn" data-filter="에테리얼">에테리얼</button>
                  <button class="filter-btn" data-filter="키티노이드">키티노이드</button>
                  <button class="filter-btn" data-filter="어비셜">어비셜</button>
             </div>
            <div id="pokedex-container" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div>
            <div id="empty-state" class="text-center py-16 px-6 bg-slate-800 rounded-2xl shadow-lg hidden"><h3 class="mt-4 text-xl font-semibold text-gray-100">도감이 비어있습니다. 첫 크리처를 소환해보세요!</h3></div>
            <div id="pagination-controls" class="text-center mt-6"></div>
        </div>
    </div>
    
    <div id="detail-view" class="view"></div>
    <div id="battle-selection-view" class="view"></div>
    <div id="battle-arena-view" class="view"></div>
    <div id="ranking-view" class="view"></div>
    <div id="profile-view" class="view"></div>
    <div id="admin-view" class="view"></div>
    <div id="manual-view" class="view"></div>

    <script type="module">
        // --- Supabase Client Setup ---
        const { createClient } = supabase;
        const SUPABASE_URL = 'https://byepyjdvhggofjjwsqna.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ5ZXB5amR2aGdnb2ZqandzcW5hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY0NjU0MjIsImV4cCI6MjA3MjA0MTQyMn0.NR1GJAm6aRYMpGZlKvfjfV2CVa2htqbtymZfmi1Owjs';
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- DOM Elements ---
        const views = document.querySelectorAll('.view');
        const modalContainer = document.getElementById('modal-container');
        const moveTooltip = document.getElementById('move-tooltip');
        const navLinks = document.getElementById('nav-links');
        const homeBtn = document.getElementById('home-btn');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const authError = document.getElementById('auth-error');
        const generateBtn = document.getElementById('generate-btn');
        const universeSelect = document.getElementById('universe-select');
        const promptInput = document.getElementById('character-prompt');
        const pokedexContainer = document.getElementById('pokedex-container');
        const emptyState = document.getElementById('empty-state');
        const errorMessage = document.getElementById('error-message');
        const btnText = document.getElementById('btn-text');
        const goToBattleBtn = document.getElementById('go-to-battle-btn');
        const goToRankingBtn = document.getElementById('go-to-ranking-btn');
        const showManualBtn = document.getElementById('show-manual-btn');
        const showRarityTableBtn = document.getElementById('show-rarity-table-btn');
        const detailViewContainer = document.getElementById('detail-view');
        const profileViewContainer = document.getElementById('profile-view');
        const manualViewContainer = document.getElementById('manual-view');
        const filterBtns = document.querySelectorAll('.filter-btn');
        const paginationControls = document.getElementById('pagination-controls');

        // --- App State & Data ---
        const appState = {
            currentUser: null,
            currentProfile: null,
            allCharacters: [],
            totalCharacterCount: 0,
            currentPage: 0,
            isLoadingMore: false,
            allProfiles: [],
            allItems: [],
            characterSubscription: null,
            activeFilter: 'all',
            battleSelection: {
                myCharacters: [],
                selectedChar: null,
                opponentsList: []
            },
        };
        const PAGE_SIZE = 12;
        
        const battleBackgrounds = [
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/arion_ground.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/desert_ground.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/ice_ground.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/lasbsgas_gorund.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/main_bg.webp'
        ];
        const typeChart = { Normal: { Rock: 0.5, Ghost: 0, Steel: 0.5 }, Fire: { Fire: 0.5, Water: 0.5, Grass: 2, Ice: 2, Bug: 2, Rock: 0.5, Dragon: 0.5, Steel: 2 }, Water: { Fire: 2, Water: 0.5, Grass: 0.5, Ground: 2, Rock: 2, Dragon: 0.5 }, Electric: { Water: 2, Electric: 0.5, Grass: 0.5, Ground: 0, Flying: 2, Dragon: 0.5 }, Grass: { Fire: 0.5, Water: 2, Grass: 0.5, Poison: 0.5, Ground: 2, Flying: 0.5, Bug: 0.5, Rock: 2, Dragon: 0.5, Steel: 0.5 }, Ice: { Fire: 0.5, Water: 0.5, Grass: 2, Ice: 0.5, Ground: 2, Flying: 2, Dragon: 2, Steel: 0.5 }, Fighting: { Normal: 2, Ice: 2, Poison: 0.5, Flying: 0.5, Psychic: 0.5, Bug: 0.5, Rock: 2, Ghost: 0, Darkness: 2, Steel: 2, Fairy: 0.5 }, Poison: { Grass: 2, Poison: 0.5, Ground: 0.5, Rock: 0.5, Ghost: 0.5, Steel: 0, Fairy: 2 }, Ground: { Fire: 2, Electric: 2, Grass: 0.5, Poison: 2, Flying: 0, Bug: 0.5, Rock: 2, Steel: 2 }, Flying: { Electric: 0.5, Grass: 2, Fighting: 2, Bug: 2, Rock: 0.5, Steel: 0.5 }, Psychic: { Fighting: 2, Poison: 2, Psychic: 0.5, Darkness: 0, Steel: 0.5 }, Bug: { Fire: 0.5, Grass: 2, Fighting: 0.5, Poison: 0.5, Flying: 0.5, Psychic: 2, Ghost: 0.5, Darkness: 2, Steel: 0.5, Fairy: 0.5 }, Rock: { Fire: 2, Ice: 2, Fighting: 0.5, Ground: 0.5, Flying: 2, Bug: 2, Steel: 0.5 }, Ghost: { Normal: 0, Psychic: 2, Ghost: 2, Darkness: 0.5, Light: 2 }, Dragon: { Dragon: 2, Steel: 0.5, Fairy: 0 }, Steel: { Fire: 0.5, Water: 0.5, Electric: 0.5, Ice: 2, Rock: 2, Steel: 0.5, Fairy: 2, Light: 0.5 }, Fairy: { Fighting: 2, Poison: 0.5, Dragon: 2, Darkness: 2, Steel: 0.5 }, Light: { Ghost: 2, Darkness: 2, Grass: 0.5, Steel: 0.5, Fire: 0.5 }, Darkness: { Psychic: 2, Ghost: 2, Light: 2, Fighting: 0.5, Fairy: 0.5 } };
        const typeTranslations = { Normal: '노말', Fire: '불꽃', Water: '물', Electric: '전기', Grass: '풀', Ice: '얼음', Fighting: '격투', Poison: '독', Ground: '땅', Flying: '비행', Psychic: '에스퍼', Bug: '벌레', Rock: '바위', Ghost: '고스트', Dragon: '드래곤', Darkness: '악', Steel: '강철', Fairy: '페어리', Light: '빛' };
        
        const UNIVERSE_PASSIVES = {
            '에테리얼': { id: 'PASSIVE_AETHERIAL', name: '에너지 과부하', text: 'HP가 가득 찬 상태로 턴을 마치면, 최대 HP의 10%만큼 보호막을 얻습니다.' },
            '키티노이드': { id: 'PASSIVE_CHITINOID', name: '적응형 갑피', text: '공격 받으면 방어 또는 특방이 1단계 상승합니다. (각 1회)' },
            '어비셜': { id: 'PASSIVE_ABYSSAL', name: '공허의 손아귀', text: '공격 시 15% 확률로 상대를 2턴간 [공허] 상태로 만들어, 회복과 버프를 막습니다.' }
        };

        const MASTER_SKILL_LIST = {
            'DMG_S': { type: 'damage', power: 50, category: 'Physical', text: '기본 위력의 공격' },
            'DMG_M': { type: 'damage', power: 90, category: 'Special', text: '강한 위력의 공격' },
            'DMG_L': { type: 'damage', power: 110, category: 'Physical', text: '강력한 공격' },
            'DMG_XL': { type: 'damage', power: 130, category: 'Special', text: '매우 강력한 공격' },
            'DMG_PRIORITY': { type: 'damage', power: 40, priority: 1, category: 'Physical', text: '위력은 낮지만 반드시 선제공격' },
            'DMG_L_RECOIL': { type: 'damage', power: 120, recoil: 0.25, category: 'Physical', text: '강력한 공격. 준 데미지의 25%를 반동으로 받음' },
            'DMG_XL_CHARGE': { type: 'damage', power: 200, charge: 1, category: 'Special', text: '1턴간 힘을 모아 다음 턴에 초강력 공격' },
            'COMBO_STARTER': { type: 'damage', power: 40, combo: 'start', category: 'Physical', text: '콤보 시동기. 다음 턴 [피니셔] 위력 2.5배' },
            'COMBO_FINISHER': { type: 'damage', power: 60, combo: 'finish', category: 'Physical', text: '콤보 피니셔. [시동기] 다음에 사용하면 위력 2.5배' },
            'BUFF_ATK_1': { type: 'buff', stat: 'attack', amount: 1, text: '자신의 공격을 1단계 상승시킨다.' },
            'DEBUFF_DEF_1': { type: 'debuff', stat: 'defense', amount: -1, text: '상대의 방어를 1단계 하락시킨다.' },
            'BUFF_ALL_1': { type: 'buff', stat: 'all', amount: 1, text: '자신의 모든 능력치를 1단계 상승시킨다.' },
            'DEBUFF_SPEED_2': { type: 'debuff', stat: 'speed', amount: -2, text: '상대의 속도를 2단계 크게 하락시킨다.' },
            'STATUS_POISON': { type: 'status', effect: 'poison', chance: 0.9, text: '90% 확률로 상대를 [독] 상태로 만든다.' },
            'STATUS_PARALYSIS': { type: 'status', effect: 'paralysis', chance: 0.9, text: '90% 확률로 상대를 [마비] 상태로 만든다.' },
            'HEAL_M': { type: 'heal', power: 0.25, text: '자신 최대 HP의 25%를 회복한다.' },
            'SHIELD_BREAK': { type: 'damage', power: 70, effect: 'shield_break', category: 'Physical', text: '상대의 보호막을 파괴하고 데미지를 준다.' },
        };
        
        const MASTER_ABILITY_LIST = {
            'GUTS': { text: '상태 이상에 걸리면 공격이 1.5배 상승한다.' },
            'TECHNICIAN': { text: '위력 60 이하 기술의 위력이 1.5배가 된다.' },
            'REGENERATOR': { text: '매 턴이 끝날 때마다 최대 체력의 1/16을 회복한다.' },
            'ADAPTABILITY': { text: '자신과 같은 타입의 기술 위력이 2배가 된다. (기존 1.5배)' },
            'MAGIC_GUARD': { text: '독, 반동 데미지 등 공격 이외의 데미지를 받지 않는다.' },
        };

        let synths = {};
        function setupAudio() {
            if (Tone.context.state !== 'running') { Tone.start(); }
            if (!synths.hit) {
                synths.hit = new Tone.MembraneSynth().toDestination();
                synths.crit = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
                synths.superEffective = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination();
                synths.victory = new Tone.PolySynth(Tone.Synth).toDestination();
                synths.uiClick = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            }
        }
        const playHitSound = () => synths.hit?.triggerAttackRelease("C2", "8n");
        const playCritSound = () => synths.crit?.triggerAttackRelease("C5", "16n");
        const playSuperEffectiveSound = () => synths.superEffective?.triggerAttackRelease("G5", "16n");
        const playVictorySound = () => synths.victory?.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", Tone.now());
        const playUiClickSound = () => synths.uiClick?.triggerAttackRelease("C5", "16n");

        function navigateTo(viewId, ...args) {
            views.forEach(v => v.classList.remove('active'));
            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.classList.add('active');
                window.scrollTo(0, 0);
                const renderFunctionName = `render${viewId.charAt(0).toUpperCase() + viewId.slice(1).replace(/-./g, x=>x[1].toUpperCase())}`;
                if (window[renderFunctionName] && typeof window[renderFunctionName] === 'function') {
                    window[renderFunctionName](...args);
                }
            }
        }
        window.navigateTo = navigateTo;
        
        function setLoadingState(isLoading) {
            generateBtn.disabled = isLoading;
            btnText.textContent = isLoading ? '생성 중...' : '크리처 소환! (1 크레딧)';
        }

        function showModal(title, content, onConfirm, options = {}) {
            const modalHTML = `
                <div id="modal-overlay" class="modal-overlay">
                    <div class="modal-content w-full max-w-lg bg-slate-800">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold">${title}</h2>
                            <button id="close-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
                        </div>
                        <div class="text-gray-300">${content}</div>
                        ${onConfirm ? '<div class="mt-6 flex justify-end gap-3"><button id="confirm-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg">확인</button><button id="cancel-btn" class="bg-slate-600 text-white font-bold py-2 px-4 rounded-lg">취소</button></div>' : ''}
                    </div>
                </div>
            `;
            modalContainer.innerHTML = modalHTML;
            document.getElementById('close-modal-btn').onclick = closeModal;
            const overlay = document.getElementById('modal-overlay');
            overlay.onclick = (e) => { 
                if (e.target === overlay && options.closeOnOverlayClick !== false) {
                    closeModal();
                }
            };
            if (onConfirm) {
                document.getElementById('confirm-btn').onclick = () => { onConfirm(); closeModal(); };
                document.getElementById('cancel-btn').onclick = closeModal;
            }
        }

        function closeModal() { modalContainer.innerHTML = ''; }
        window.closeModal = closeModal;
        
        function showToast(message, type = 'success') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            const bgColor = type === 'success' ? 'bg-green-500' : 'bg-yellow-500';
            toast.className = `p-3 rounded-lg shadow-xl text-white ${bgColor} transform transition-all duration-300 ease-in-out translate-x-full opacity-0`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            requestAnimationFrame(() => {
                toast.classList.remove('translate-x-full', 'opacity-0');
            });
            setTimeout(() => {
                toast.classList.add('translate-x-full', 'opacity-0');
                toast.addEventListener('transitionend', () => toast.remove());
            }, 4000);
        }

        function showRarityModal() {
            const content = `
                <table class="w-full text-left text-gray-300">
                    <thead><tr class="bg-slate-700"><th class="p-2">등급</th><th class="p-2">총 능력치 (BST)</th><th class="p-2">확률</th></tr></thead>
                    <tbody>
                        <tr class="border-b border-slate-600"><td class="p-2"><span class="rarity-badge rarity-신화">신화</span></td><td class="p-2">780 ~</td><td class="p-2">5%</td></tr>
                        <tr class="border-b border-slate-600"><td class="p-2"><span class="rarity-badge rarity-고대">고대</span></td><td class="p-2">660 - 779</td><td class="p-2">10%</td></tr>
                        <tr class="border-b border-slate-600"><td class="p-2"><span class="rarity-badge rarity-전설">전설</span></td><td class="p-2">540 - 659</td><td class="p-2">15%</td></tr>
                        <tr class="border-b border-slate-600"><td class="p-2"><span class="rarity-badge rarity-에픽">에픽</span></td><td class="p-2">420 - 539</td><td class="p-2">20%</td></tr>
                        <tr class="border-b border-slate-600"><td class="p-2"><span class="rarity-badge rarity-희귀">희귀</span></td><td class="p-2">300 - 419</td><td class="p-2">25%</td></tr>
                        <tr><td class="p-2"><span class="rarity-badge rarity-일반">일반</span></td><td class="p-2">~ 299</td><td class="p-2">25%</td></tr>
                    </tbody>
                </table>
            `;
            showModal('캐릭터 등급표', content);
        }

        function showTypeChartModal() {
            const allTypes = Object.keys(typeTranslations);
            const headerHtml = allTypes.map(type => `<th class="p-1 text-center text-xs sticky top-0 bg-slate-700">${typeTranslations[type]}</th>`).join('');

            const bodyHtml = allTypes.map(attackerType => {
                const attackerRow = allTypes.map(defenderType => {
                    const effectiveness = typeChart[attackerType]?.[defenderType] ?? 1;
                    let className = '';
                    let symbol = '1';
                    if (effectiveness > 1) { className = 'text-green-400 font-bold'; symbol = '▲'; }
                    else if (effectiveness < 1 && effectiveness > 0) { className = 'text-red-400'; symbol = '▼'; }
                    else if (effectiveness === 0) { className = 'text-gray-500'; symbol = 'X'; }
                    return `<td class="p-1 text-center ${className}">${symbol}</td>`;
                }).join('');
                const translatedAttackerType = typeTranslations[attackerType];
                return `<tr class="border-b border-slate-700"><td class="p-1 font-bold text-cyan-400 text-xs sticky left-0 bg-slate-800">${translatedAttackerType}</td>${attackerRow}</tr>`;
            }).join('');

            const content = `
                <style>
                    .type-chart-container { max-height: 70vh; overflow: auto; }
                    .type-chart-table th, .type-chart-table td { border: 1px solid #334155; white-space: nowrap; }
                </style>
                <div class="type-chart-container">
                    <p class="mb-4 text-sm text-gray-400">공격 타입(좌측)이 방어 타입(상단)을 공격할 때의 효과입니다.<br>▲: 효과가 굉장함, ▼: 효과가 별로임, X: 효과가 없음, 1: 보통</p>
                    <table class="w-full text-xs text-slate-300 border-collapse type-chart-table">
                        <thead>
                            <tr>
                                <th class="p-1 sticky top-0 left-0 bg-slate-700 z-10">공격/방어</th>
                                ${headerHtml}
                            </tr>
                        </thead>
                        <tbody>${bodyHtml}</tbody>
                    </table>
                </div>
            `;
            showModal('타입 상성표', content);
        }
        
        function showBattleLogModal(log) {
            const logHtml = log.map(entry => `<p class="text-sm text-left p-1 border-b border-slate-700">${entry}</p>`).join('');
            const content = `<div class="max-h-60 overflow-y-auto bg-slate-900 p-2 rounded">${logHtml}</div>`;
            showModal('전투 기록', content);
        }


        function updateUIBasedOnAuthState() {
            navLinks.innerHTML = '';
            const characterCreationSection = document.getElementById('character-creation-section');
            if (appState.currentUser && appState.currentProfile) {
                const nickname = appState.currentProfile.nickname || appState.currentUser.email.split('@')[0];
                navLinks.innerHTML = `
                    <span class="font-bold text-xs sm:text-base text-gray-300 hidden md:inline">환영합니다, ${nickname}님!</span>
                    <span class="font-bold text-xs sm:text-base text-yellow-400">크레딧: ${appState.currentProfile.credits}</span>
                    <button class="font-bold text-xs sm:text-base text-sky-400 hover:underline p-1 sm:p-2" id="profile-btn">마이페이지</button>
                    ${appState.currentProfile.is_admin ? `<button id="admin-btn" class="font-bold text-xs sm:text-base text-purple-400 hover:underline p-1 sm:p-2">관리자</button>` : ''}
                    <button id="logout-btn" class="font-bold text-xs sm:text-base text-red-400 hover:underline p-1 sm:p-2">로그아웃</button>
                `;
                document.getElementById('profile-btn').onclick = () => navigateTo('profile-view', appState.currentUser.id);
                if (appState.currentProfile.is_admin) document.getElementById('admin-btn').onclick = () => navigateTo('admin-view');
                document.getElementById('logout-btn').onclick = handleLogout;
                characterCreationSection.style.display = 'block';
                goToBattleBtn.disabled = false;
            } else {
                navLinks.innerHTML = `<button id="login-signup-btn" class="font-bold text-sky-400 hover:underline p-2">로그인 / 회원가입</button>`;
                document.getElementById('login-signup-btn').onclick = () => navigateTo('auth-view');
                characterCreationSection.style.display = 'none';
                goToBattleBtn.disabled = true;
            }
        }
        
        async function initialDataLoad() {
            try {
                const { data: profilesData, error: profilesError } = await supabaseClient.from('battle_profiles').select('*');
                if (profilesError) throw profilesError;
                appState.allProfiles = profilesData;

                const { data: itemsData, error: itemsError } = await supabaseClient.from('items').select('*');
                if (itemsError) {
                    console.warn("Warning: Could not load 'items' table. Item features will be disabled.", itemsError);
                    showToast("아이템 정보를 불러오지 못했습니다. DB 스크립트를 실행했는지 확인해주세요.", "error");
                    appState.allItems = [];
                } else {
                    appState.allItems = itemsData;
                }

                if (appState.currentUser) {
                    appState.currentProfile = appState.allProfiles.find(p => p.id === appState.currentUser.id);
                }
                
                appState.allCharacters = [];
                appState.currentPage = 0;
                await loadMoreCharacters();
                
                updateUIBasedOnAuthState();
                navigateTo('pokedex-view');

            } catch (error) {
                console.error("Error on initial data load:", error);
                showModal('데이터 로딩 오류', `<p>필수 데이터를 불러오는 데 실패했습니다: ${error.message}</p><p>Supabase 데이터베이스의 테이블과 RLS(보안 정책)이 올바르게 설정되었는지 확인해주세요.</p>`);
            }
        }

        function handleRealtimeChanges(payload) {
            console.log('Realtime change received:', payload);
            const { eventType, new: newRecord, old: oldRecord, table } = payload;
            let id = eventType === 'DELETE' ? oldRecord.id : newRecord.id;

            if (table === 'battle_characters' || table === 'battle_records' || table === 'user_inventories') {
                const activeView = document.querySelector('.view.active');
                if (activeView && (activeView.id === 'pokedex-view' || activeView.id === 'detail-view' || activeView.id === 'profile-view' || activeView.id === 'ranking-view')) {
                    appState.allCharacters = [];
                    appState.currentPage = 0;
                    loadMoreCharacters();
                }
            } else if (table === 'battle_profiles') {
                const index = appState.allProfiles.findIndex(p => p.id === id);
                if (eventType === 'INSERT' && index === -1) {
                    appState.allProfiles.push(newRecord);
                } else if (eventType === 'UPDATE' && index > -1) {
                    appState.allProfiles[index] = { ...appState.allProfiles[index], ...newRecord };
                }
            }
            
            const activeView = document.querySelector('.view.active');
            if (activeView && activeView.id !== 'battle-arena-view') {
                const renderFunctionName = `render${activeView.id.charAt(0).toUpperCase() + activeView.id.slice(1).replace(/-./g, x=>x[1].toUpperCase())}`;
                if (window[renderFunctionName] && typeof window[renderFunctionName] === 'function') {
                    const currentId = activeView.dataset.id;
                    window[renderFunctionName](currentId);
                }
            }
            if (document.getElementById('pokedex-view').classList.contains('active')) {
                renderPokedexView();
                renderRankingPodium();
            }
            if (appState.currentUser && appState.currentProfile && id === appState.currentUser.id) {
                appState.currentProfile = appState.allProfiles.find(p => p.id === appState.currentUser.id);
                updateUIBasedOnAuthState();
            }
        }

        function subscribeToChanges() {
            if (appState.characterSubscription) appState.characterSubscription.unsubscribe();
            appState.characterSubscription = supabaseClient.channel('hipoketmon-db-changes')
                .on('postgres_changes', { event: '*', schema: 'public' }, handleRealtimeChanges)
                .subscribe();
        }

        async function listenToAuthStateChanges() {
            supabaseClient.auth.onAuthStateChange(async (_event, session) => {
                const wasSignedOut = !appState.currentUser;
                appState.currentUser = session?.user || null;
                
                if (appState.currentUser) {
                    appState.currentProfile = appState.allProfiles.find(p => p.id === appState.currentUser.id);
                    if (!appState.currentProfile) {
                        const { data } = await supabaseClient.from('battle_profiles').select('*');
                        if(data) appState.allProfiles = data;
                        appState.currentProfile = appState.allProfiles.find(p => p.id === appState.currentUser.id);
                    }
                } else {
                    appState.currentProfile = null;
                }
                
                updateUIBasedOnAuthState();

                if (wasSignedOut && appState.currentUser) {
                    navigateTo('pokedex-view');
                } else if (!appState.currentUser) {
                    const protectedViews = ['profile-view', 'battle-selection-view', 'admin-view'];
                    const currentView = document.querySelector('.view.active')?.id || 'pokedex-view';
                    if (protectedViews.includes(currentView)) {
                        navigateTo('pokedex-view');
                    }
                }
            });
        }

        async function handleSignup(e) {
            e.preventDefault();
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;
            const { error } = await supabaseClient.auth.signUp({ 
                email, 
                password,
                options: { emailRedirectTo: window.location.origin }
            });
            if (error) { authError.textContent = `회원가입 오류: ${error.message}`; } 
            else {
                authError.textContent = '';
                showModal('회원가입 확인', `<p><strong>${email}</strong>(으)로 확인 이메일을 보냈습니다.</p><p class="mt-2">이메일 수신함의 링크를 클릭하여 가입을 완료해주세요.</p>`);
            }
        }

        async function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
            if (error) { authError.textContent = `로그인 오류: ${error.message}`; } 
            else { authError.textContent = ''; }
        }

        async function handleLogout() {
            await supabaseClient.auth.signOut();
        }
        
        async function generateCharacter() {
            if (!appState.currentUser) { showModal('로그인 필요', '<p>캐릭터를 생성하려면 로그인이 필요합니다.</p>'); navigateTo('auth-view'); return; }
            const { data: freshProfile, error: profileError } = await supabaseClient.from('battle_profiles').select('credits').eq('id', appState.currentUser.id).single();
            if (profileError) { showModal('오류', `<p>프로필 정보를 불러오는 데 실패했습니다: ${profileError.message}</p>`); return; }
            appState.currentProfile.credits = freshProfile.credits;
            updateUIBasedOnAuthState();
            if (appState.currentProfile.credits < 1) { showModal('크레딧 부족', '<p>크레딧이 부족합니다. 매일 마이페이지에서 출석체크로 크레딧을 얻으세요!</p>'); return; }
            const userPrompt = promptInput.value.trim();
            if (!userPrompt) { errorMessage.textContent = '생성할 캐릭터에 대한 아이디어를 입력해주세요.'; return; }
            setLoadingState(true);
            errorMessage.textContent = '캐릭터 컨셉 구상 중... (최대 1분 소요)';
            try {
                const universe = universeSelect.value;
                const { rarity, bstRange } = determineRarityAndBST();
                const [pngImageUrlBase64, newCharData] = await Promise.all([ 
                    generateCharacterImage(userPrompt, universe), 
                    generateCharacterData(userPrompt, universe, rarity, bstRange) 
                ]);
                errorMessage.textContent = '이미지 최적화 중...';
                const webpImageUrlBase64 = await convertImageToWebP(pngImageUrlBase64);
                errorMessage.textContent = '캐릭터를 현실 세계로 소환하는 중...';
                const imageBlob = base64ToBlob(webpImageUrlBase64, 'image/webp');
                const filePath = `${appState.currentUser.id}/${Date.now()}.webp`;
                const { error: uploadError } = await supabaseClient.storage.from('battle_images').upload(filePath, imageBlob);
                if (uploadError) throw uploadError;
                const { data: { publicUrl } } = supabaseClient.storage.from('battle_images').getPublicUrl(filePath);
                const finalCharacterData = { ...newCharData, rarity };
                const { error: insertError } = await supabaseClient.from('battle_characters').insert({ creator_id: appState.currentUser.id, image_url: publicUrl, data: finalCharacterData, universe: universe });
                if (insertError) throw insertError;
                const { error: creditError } = await supabaseClient.from('battle_profiles').update({ credits: appState.currentProfile.credits - 1 }).eq('id', appState.currentUser.id);
                if (creditError) throw creditError;
                appState.currentProfile.credits -= 1;
                updateUIBasedOnAuthState();
                promptInput.value = '';
                errorMessage.textContent = '';
                showModal('생성 성공!', `<p>새로운 캐릭터 <strong>${finalCharacterData.name}</strong>(${rarity})이(가) 도감에 추가되었습니다!</p>`);
                appState.allCharacters = [];
                appState.currentPage = 0;
                await loadMoreCharacters();
            } catch (error) {
                console.error("Character Generation Error:", error);
                let displayError = error.message;
                if (error.message.includes("security policy")) {
                    displayError = `파일 저장소(Storage)의 보안 정책(RLS)이 설정되지 않았습니다. Supabase 대시보드에서 'battle_images' 버킷에 대한 SELECT, INSERT, DELETE 정책을 올바르게 설정해주세요.`;
                }
                showModal('생성 실패', `<p>생성 중 오류가 발생했습니다. 크레딧은 차감되지 않았습니다. <br>오류: ${displayError}</p>`);
                errorMessage.textContent = `⚠️ 생성 중 오류가 발생했습니다.`;
            } finally {
                setLoadingState(false);
            }
        }
        function determineRarityAndBST() {
            const rarityData = [
                { rarity: '신화', bstRange: { min: 780, max: 850 }, weight: 5 },
                { rarity: '고대', bstRange: { min: 660, max: 779 }, weight: 10 },
                { rarity: '전설', bstRange: { min: 540, max: 659 }, weight: 15 },
                { rarity: '에픽', bstRange: { min: 420, max: 539 }, weight: 20 },
                { rarity: '희귀', bstRange: { min: 300, max: 419 }, weight: 25 },
                { rarity: '일반', bstRange: { min: 250, max: 299 }, weight: 25 },
            ];
            const rarityPool = rarityData.flatMap(r => Array(r.weight).fill(r));
            return rarityPool[Math.floor(Math.random() * rarityPool.length)];
        }
        async function callApiWithRetry(apiUrl, payload, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        if (response.status === 429) { await new Promise(res => setTimeout(res, delay * (i + 1))); continue; }
                        throw new Error(`API Error (${response.status}): ${await response.text()}`);
                    }
                    return response.json();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(res => setTimeout(res, delay * (i + 1)));
                }
            }
        }
        async function generateCharacterImage(prompt, universe) {
            const apiKey = "";
            const universeStyleGuide = {
                "에테리얼": "ethereal cosmic creature, translucent body, glowing with internal light, swirling nebula patterns, celestial, made of pure energy, bioluminescent, astral",
                "키티노이드": "bio-mechanical insectoid warrior, chitinous armor, sharp mandibles, multiple glowing eyes, tough exoskeleton, predatory, beetle-like carapace",
                "어비셜": "lovecraftian horror from the void, shadowy tentacles, countless glowing eyes, amorphous, deep sea leviathan, abyssal terror, creature of darkness"
            };
            const stylePrompt = universeStyleGuide[universe] || "high-quality fantasy monster";
            const fullPrompt = `Full-body image of a unique creature, core concept: "${prompt}". Species: '${universe}' with their visual traits. Style: "${stylePrompt}". Clean white background.`;
            const payload = { contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { responseModalities: ['IMAGE'] }, };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
            const result = await callApiWithRetry(apiUrl, payload);
            const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
            if (base64Data) { return `data:image/png;base64,${base64Data}`; }
            throw new Error("Image data was not returned from the API.");
        }
        async function generateCharacterData(prompt, universe, rarity, bstRange) {
            const apiKey = "";
            const skillListForPrompt = Object.entries(MASTER_SKILL_LIST).map(([id, skill]) => `- ${id} (${skill.category}): ${skill.text}`).join('\n');
            const abilityListForPrompt = Object.entries(MASTER_ABILITY_LIST).map(([id, ability]) => `- ${id}: ${ability.text}`).join('\n');
            const basePrompt = `
**생성 규칙:**
1.  **등급/BST 준수:** "${rarity}" 등급, 총 능력치(BST)는 ${bstRange.min}~${bstRange.max} 사이.
2.  **정확한 ID 선택:** 'moveId'와 'ability.id'는 반드시 아래 **마스터 리스트**에 명시된 **정확한 ID** 중에서만 선택해야 합니다.
3.  **데미지 스킬 포함:** 선택하는 기술 4개 중 2개 이상은 반드시 'damage' 타입 스킬이어야 합니다.
4.  **창의적 이름 부여:** 선택한 기술/특성 ID에 컨셉에 맞는 멋진 한국어 이름을 새로 지어주세요.
5.  **능력치 분배:** 체력(HP)은 다른 스탯보다 4~6배 높게 설정.
6.  **타입 선택:** (${Object.keys(typeTranslations).join(', ')}) 중에서 2개를 선택.

**마스터 스킬 리스트:**
${skillListForPrompt}
**마스터 특성 리스트:**
${abilityListForPrompt}

**사용자 컨셉:** "${prompt}". 이 크리처는 '${universe}' 종족입니다. JSON 스키마에 맞춰 한국어로 답변해주세요.`;
            const schema = { type: "OBJECT", properties: { name: { type: "STRING" }, types: { type: "ARRAY", items: { type: "STRING" } }, ability: { type: "OBJECT", properties: { id: { type: "STRING" }, name: { type: "STRING" } } }, height: { type: "NUMBER" }, weight: { type: "NUMBER" }, pokedexEntry: { type: "STRING" }, stats: { type: "OBJECT", properties: { hp: { type: "INTEGER" }, attack: { type: "INTEGER" }, defense: { type: "INTEGER" }, sp_atk: { type: "INTEGER" }, sp_def: { type: "INTEGER" }, speed: { type: "INTEGER" } } }, moves: { type: "ARRAY", items: { type: "OBJECT", properties: { moveId: { type: "STRING" }, name: { type: "STRING" }, description: { type: "STRING" }, type: { type: "STRING" } } } } }, required: ["name", "types", "ability", "pokedexEntry", "stats", "moves"] };
            const payload = { contents: [{ parts: [{ text: basePrompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const result = await callApiWithRetry(apiUrl, payload);
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) { return JSON.parse(result.candidates[0].content.parts[0].text); }
            throw new Error("Character data generation failed or returned in an unexpected format.");
        }
        function base64ToBlob(base64, contentType = '', sliceSize = 512) {
            const byteCharacters = atob(base64.split(',')[1]);
            const byteArrays = [];
            for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                const slice = byteCharacters.slice(offset, offset + sliceSize);
                const byteNumbers = new Array(slice.length);
                for (let i = 0; i < slice.length; i++) byteNumbers[i] = slice.charCodeAt(i);
                byteArrays.push(new Uint8Array(byteNumbers));
            }
            return new Blob(byteArrays, { type: contentType });
        }
        function convertImageToWebP(base64Png, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    canvas.getContext('2d').drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/webp', quality));
                };
                img.onerror = (err) => reject(new Error("Failed to load image for WebP conversion."));
                img.src = base64Png;
            });
        }
        function createElement(tag, attributes = {}, children = []) {
            const element = document.createElement(tag);
            for (const key in attributes) {
                if (key === 'className') { element.className = attributes[key]; } 
                else if (key === 'textContent') { element.textContent = attributes[key]; } 
                else if (key.startsWith('data-')) {
                    const datasetKey = key.substring(5).replace(/-(\w)/g, (match, letter) => letter.toUpperCase());
                    element.dataset[datasetKey] = attributes[key];
                }
                else { element.setAttribute(key, attributes[key]); }
            }
            children.forEach(child => {
                if (typeof child === 'string') { element.appendChild(document.createTextNode(child)); } 
                else if (child) { element.appendChild(child); }
            });
            return element;
        }

        const statStageMultipliers = { '-6': 2/8, '-5': 2/7, '-4': 2/6, '-3': 2/5, '-2': 2/4, '-1': 2/3, '0': 1, '1': 3/2, '2': 4/2, '3': 5/2, '4': 6/2, '5': 7/2, '6': 8/2 };
        function getStatMultiplier(stage) { return statStageMultipliers[stage] || 1; }

        function calculateDamage(attacker, defender, move, turn) {
            const masterMove = MASTER_SKILL_LIST[move.moveId] || {};
            if (masterMove.type !== 'damage' || !masterMove.power) return { damage: 0, isCritical: false, effectiveness: 1 };
            let basePower = masterMove.power;
            if (attacker.battleStatus.ability?.id === 'TECHNICIAN' && basePower <= 60) basePower *= 1.5;
            if (attacker.battleStatus.comboReady && masterMove.combo === 'finish') basePower *= 2.5;
            const isPhysical = (masterMove.category || 'Physical') === 'Physical';
            let atkStat = isPhysical ? attacker.stats.attack * getStatMultiplier(attacker.battleStatus.stat_stages.attack) : attacker.stats.sp_atk * getStatMultiplier(attacker.battleStatus.stat_stages.sp_atk);
            const defStat = isPhysical ? defender.stats.defense * getStatMultiplier(defender.battleStatus.stat_stages.defense) : defender.stats.sp_def * getStatMultiplier(defender.battleStatus.stat_stages.sp_def);
            if (attacker.battleStatus.ability?.id === 'GUTS' && attacker.battleStatus.status && isPhysical) atkStat *= 1.5;
            if (attacker.battleStatus.isDesperate) atkStat *= 1.25;
            let damage = (((2 * attacker.level / 5 + 2) * atkStat * basePower / defStat) / 50) * 1.4 + 2;
            let effectiveness = 1;
            defender.types.forEach(defType => {
                const moveTypeKey = Object.keys(typeTranslations).find(key => typeTranslations[key] === move.type) || move.type;
                effectiveness *= typeChart[moveTypeKey]?.[defType] ?? 1;
            });
            let stab = 1;
            if (attacker.types.some(t => typeTranslations[t] === move.type)) {
                stab = attacker.battleStatus.ability?.id === 'ADAPTABILITY' ? 2 : 1.5;
            }
            damage *= effectiveness * stab;
            damage *= (1 + (turn - 1) * 0.05);
            const isCritical = Math.random() < 0.125;
            if (isCritical) damage *= 1.5;
            let finalDamage = Math.floor(damage * (Math.random() * 0.15 + 0.85));
            return { damage: finalDamage, isCritical, effectiveness };
        }

        async function updatePostBattleStats(winner, loser) {
            try {
                // 1. Fetch current records for winner and loser
                const { data: winnerRecordData, error: winnerRecordError } = await supabaseClient.from('battle_records').select('wins, losses').eq('character_id', winner.id).maybeSingle();
                if (winnerRecordError) throw winnerRecordError;
                
                const { data: loserRecordData, error: loserRecordError } = await supabaseClient.from('battle_records').select('wins, losses').eq('character_id', loser.id).maybeSingle();
                if (loserRecordError) throw loserRecordError;

                const winnerRecord = winnerRecordData || { wins: 0, losses: 0 };
                const loserRecord = loserRecordData || { wins: 0, losses: 0 };

                // 2. Calculate Rank Points
                const K = 32;
                const winnerRank = winner.rank_points || 1000;
                const loserRank = loser.rank_points || 1000;
                const winnerExpected = 1 / (1 + 10 ** ((loserRank - winnerRank) / 400));
                
                const rankChange = Math.round(K * (1 - winnerExpected));
                
                const newWinnerRank = winnerRank + rankChange;
                const newLoserRank = Math.max(0, loserRank + Math.round(K * (0 - (1 - winnerExpected))));
                const loserRankChange = newLoserRank - loserRank;

                // 3. Calculate XP and handle Level Up
                let xpGained = Math.max(10, 50 + (loser.level - winner.level) * 5);
                if (winner.level < loser.level && (loser.level - winner.level >= 5)) {
                    xpGained *= 2; // Underdog bonus
                }

                const newExperience = (winner.experience || 0) + xpGained;
                let newLevel = winner.level || 1;
                let newStats = winner.stats;
                let leveledUp = false;
                
                const xpForNextLevel = 100 * newLevel;
                if (newExperience >= xpForNextLevel) {
                    newLevel++;
                    leveledUp = true;
                    // Increase stats upon level up
                    newStats = {
                        hp: winner.stats.hp + Math.floor(Math.random() * 6) + 5, // HP gets a bit more
                        attack: winner.stats.attack + Math.floor(Math.random() * 3) + 1,
                        defense: winner.stats.defense + Math.floor(Math.random() * 3) + 1,
                        sp_atk: winner.stats.sp_atk + Math.floor(Math.random() * 3) + 1,
                        sp_def: winner.stats.sp_def + Math.floor(Math.random() * 3) + 1,
                        speed: winner.stats.speed + Math.floor(Math.random() * 3) + 1,
                    };
                }
                
                // 4. Prepare data for winner update
                const winnerDataToUpdate = {
                    rank_points: newWinnerRank,
                    experience: newExperience,
                    level: newLevel,
                };
                if (leveledUp) {
                     const winnerFullData = winner;
                    // We need to update the `data` column which is a JSONB
                    winnerFullData.stats = newStats;
                    winnerFullData.level = newLevel; // Make sure level inside JSON is also updated if it exists
                    
                    // Clean up non-JSON data before updating the `data` column
                    delete winnerFullData.id;
                    delete winnerFullData.creator_id;
                    delete winnerFullData.image_url;
                    delete winnerFullData.created_at;
                    delete winnerFullData.universe;
                    delete winnerFullData.rank_points;
                    delete winnerFullData.level;
                    delete winnerFullData.experience;
                    delete winnerFullData.profile;
                    delete winnerFullData.record;
                    delete winnerFullData.battleStatus;

                    winnerDataToUpdate.data = winnerFullData;
                }

                const winnerCharUpdatePromise = supabaseClient
                    .from('battle_characters')
                    .update(winnerDataToUpdate)
                    .eq('id', winner.id);
                    
                const loserCharUpdatePromise = supabaseClient
                    .from('battle_characters')
                    .update({ rank_points: newLoserRank })
                    .eq('id', loser.id);
                    
                const winnerRecordUpdatePromise = supabaseClient.from('battle_records').upsert({
                    character_id: winner.id,
                    wins: winnerRecord.wins + 1,
                    losses: winnerRecord.losses
                });

                const loserRecordUpdatePromise = supabaseClient.from('battle_records').upsert({
                    character_id: loser.id,
                    wins: loserRecord.wins,
                    losses: loserRecord.losses + 1,
                });

                const results = await Promise.all([
                    winnerCharUpdatePromise,
                    loserCharUpdatePromise,
                    winnerRecordUpdatePromise,
                    loserRecordUpdatePromise
                ]);

                results.forEach(res => { if(res.error) throw res.error; });

                let droppedItemId = null;
                 if (Math.random() < 0.25 && appState.allItems.length > 0) {
                    const randomItem = appState.allItems[Math.floor(Math.random() * appState.allItems.length)];
                    droppedItemId = randomItem.id;
                    const { error: inventoryError } = await supabaseClient.rpc('add_to_inventory', { 
                        p_user_id: winner.creator_id, 
                        p_item_id: droppedItemId, 
                        p_quantity_to_add: 1 
                    });
                    if (inventoryError) {
                        console.error("Failed to add item to inventory via RPC:", inventoryError);
                    }
                }
                
                return { rankChange, loserRankChange, droppedItemId, leveledUp, xpGained, newLevel };

            } catch (error) {
                console.error("Error processing battle results:", error);
                showToast("전투 결과를 저장하는 데 실패했습니다.", "error");
                return { rankChange: 0, loserRankChange: 0, droppedItemId: null, leveledUp: false, xpGained: 0, newLevel: winner.level };
            }
        }
        
        function chooseSmartMove(attacker, defender) {
            const hasDamagingMove = attacker.moves.some(m => MASTER_SKILL_LIST[m.moveId]?.type === 'damage');

            let moveScores = attacker.moves.map((move) => {
                const masterMove = MASTER_SKILL_LIST[move.moveId] || {};
                let score = 0;
                
                if (masterMove.type === 'damage') {
                    let { damage, effectiveness } = calculateDamage(attacker, defender, move, 1);
                    const isLethal = damage >= defender.battleStatus.currentHP;
                    
                    if (isLethal) return { move, score: 10000 }; 
                    
                    score += damage * 1.5; // Prioritize damage
                    if (effectiveness > 1) score *= 2; // Heavily prioritize super-effective
                    if (effectiveness < 1) score *= 0.2; // Avoid not very effective
                    
                } else {
                     // Lower base score for non-damaging moves if a damage move is available
                    score = hasDamagingMove ? 10 : 40;

                    switch (masterMove.type) {
                        case 'heal':
                            const missingHpPercent = 1 - (attacker.battleStatus.currentHP / attacker.battleStatus.maxHP);
                            if (missingHpPercent > 0.6) score += 120; // High priority heal
                            else if (missingHpPercent > 0.3) score += 50;
                            break;
                        case 'buff':
                            if (masterMove.stat !== 'all' && attacker.battleStatus.stat_stages[masterMove.stat] < 2) {
                                score += 35; // Buff if not already significantly buffed
                            }
                            break;
                        case 'debuff':
                             if (masterMove.stat !== 'all' && defender.battleStatus.stat_stages[masterMove.stat] > -2) {
                                score += 30; // Debuff if not already significantly debuffed
                            }
                            break;
                        case 'status':
                            if (!defender.battleStatus.status) score += 45; // High priority to inflict status if none exists
                            break;
                    }
                }
                score += Math.random() * 5; 
                return { move, score };
            });

            moveScores.sort((a, b) => b.score - a.score);
            return moveScores[0].move;
        }

        function initializeFighter(fighter) {
            fighter.battleStatus = {
                currentHP: fighter.stats.hp, maxHP: fighter.stats.hp, status: null,
                stat_stages: { attack: 0, defense: 0, sp_atk: 0, sp_def: 0, speed: 0 },
                isDesperate: false, shield: 0, comboReady: false, chargingMove: null,
                passiveUsed: { 'PASSIVE_CHITINOID': { defense: false, sp_def: false } }, voided: 0,
                statusTurns: 0,
            };
        }
        
        async function loadMoreCharacters() {
            if (appState.isLoadingMore) return;
            appState.isLoadingMore = true;
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) { loadMoreBtn.textContent = '불러오는 중...'; loadMoreBtn.disabled = true; }
            const from = appState.currentPage * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;
            let query = supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email), record:battle_records(*)', { count: 'exact' })
                .order('created_at', { ascending: false })
                .range(from, to);
            if (appState.activeFilter !== 'all') { query = query.eq('universe', appState.activeFilter); }
            const { data, error, count } = await query;
            if (error) {
                console.error("Error fetching more characters:", error);
                showModal('오류', '캐릭터를 더 불러오는 데 실패했습니다.');
            } else {
                appState.totalCharacterCount = count;
                const newCharacters = data.map(c => ({ ...c.data, id: c.id, created_at: c.created_at, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, level: c.level, experience: c.experience, universe: c.universe, profile: c.profile, record: Array.isArray(c.record) && c.record.length > 0 ? c.record[0] : null }));
                appState.allCharacters.push(...newCharacters);
                appState.currentPage++;
                renderPokedexView();
            }
            appState.isLoadingMore = false;
        }

        function createCharacterCard(char, variant = 'default') {
            if (!char || !char.stats) { console.warn("Character with missing data, skipping card render:", char); return document.createDocumentFragment(); }
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            const imageUrl = `${char.image_url}?width=${variant === 'small' ? 128 : 320}&quality=80`;
            const record = char.record || { wins: 0, losses: 0 };
            
            const card = createElement('div', { className: `pokedex-card rounded-lg shadow-md p-4 card-border-${char.rarity}`, 'data-char-id': char.id });
            
            const imageContainer = createElement('div', { className: 'relative w-full sm:w-40 h-40 bg-slate-700 rounded-lg flex items-center justify-center' }, [
                createElement('div', { className: 'level-display', textContent: `LV.${char.level || 1}` }),
                createElement('img', { src: imageUrl, alt: char.name, className: 'absolute top-0 left-0 w-full h-full object-cover rounded-lg', loading: 'lazy', onerror: "this.parentElement.innerHTML = '<span class=\\'text-xs text-gray-400\\'>Image Error</span>';" })
            ]);
            
            const infoContainer = createElement('div', { className: 'flex-1' }, [
                createElement('h3', { className: 'font-bold text-lg sm:text-xl' }, [
                    document.createTextNode(char.name + ' '),
                    createElement('span', { className: 'text-sm text-gray-500', textContent: `(${char.universe || 'Unknown'})` })
                ]),
                createElement('div', { className: 'flex items-center gap-2 my-1' }, [
                    createElement('span', { className: `rarity-badge text-xs`, textContent: char.rarity }),
                ]),
                createElement('div', { className: 'flex gap-1 sm:gap-2 my-2 flex-wrap' }, char.types.map(t => createElement('span', { className: `type-badge text-xs`, textContent: typeTranslations[t] || t }))),
                createElement('p', { className: 'text-xs sm:text-sm text-gray-400' }, [
                    document.createTextNode('소환사: '),
                    createElement('a', { href: '#', 'data-profile-id': char.creator_id, className: 'text-sky-400 hover:underline', textContent: creatorName })
                ])
            ]);

            const bst = Object.values(char.stats).reduce((a, b) => a + b, 0);
            const statsContainer = createElement('div', { className: 'mt-4' }, [
                createElement('div', { className: 'text-xs font-bold text-gray-500 mb-1', textContent: `능력치 (BST: ${bst})` }),
                ...Object.entries(char.stats).map(([stat, value]) => 
                    createElement('div', { className: 'flex items-center gap-2 text-xs mb-1' }, [
                        createElement('span', { className: 'w-12 font-semibold text-gray-400', textContent: {hp:'HP', attack:'공격', defense:'방어', sp_atk:'특공', sp_def:'특방', speed:'속도'}[stat] }),
                        createElement('div', { className: 'flex-1 stat-bar-bg' }, [
                            createElement('div', { className: 'stat-bar h-2', style: `width: ${Math.min(100, (value / (stat === 'hp' ? 300 : 150)) * 100)}%;` })
                        ]),
                        createElement('span', { className: 'w-8 text-right font-bold', textContent: value })
                    ])
                )
            ]);
            
            card.append(
                createElement('div', { className: 'flex flex-col sm:flex-row gap-4' }, [imageContainer, infoContainer]),
                statsContainer,
                createElement('div', { className: 'rank-display', textContent: `${char.rank_points || 1000} RP` })
            );

            return card;
        }

        function renderPokedexView() {
            renderRankingPodium();
            if (appState.currentPage === 1) {
                pokedexContainer.innerHTML = '';
            }

            if (appState.allCharacters.length === 0 && !appState.isLoadingMore) {
                emptyState.style.display = 'block';
                pokedexContainer.style.display = 'none';
            } else {
                emptyState.style.display = 'none';
                pokedexContainer.style.display = 'grid';
                const existingCardIds = new Set([...pokedexContainer.children].map(card => card.dataset.charId));
                const newCharacters = appState.allCharacters.filter(char => !existingCardIds.has(String(char.id)));
                newCharacters.forEach(char => {
                    pokedexContainer.appendChild(createCharacterCard(char, 'default'));
                });
            }
            updatePaginationControls();
        }
        window.renderPokedexView = renderPokedexView;

        async function renderRankingPodium() {
            const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .order('rank_points', { ascending: false, nullsFirst: false })
                .limit(3);
            if (error) { console.error('Error fetching podium data:', error); return; }
            
            const top3 = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile }));
            
            const rankingPodiumView = document.getElementById('ranking-podium-view');
            rankingPodiumView.innerHTML = '';

            const podiumData = {
                first: top3[0] || null,
                second: top3[1] || null,
                third: top3[2] || null
            };

            const createPodiumItem = (char, rank) => {
                if (!char) return '';
                const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
                const imageUrl = `${char.image_url}?width=256&quality=85`;
                return `
                <div class="podium-item podium-${rank}" data-char-id="${char.id}">
                    <p class="text-3xl font-bold mb-2">${rank === 1 ? '🥇' : rank === 2 ? '🥈' : '🥉'}</p>
                    <img src="${imageUrl}" class="podium-img">
                    <div class="podium-base flex flex-col justify-end items-center p-2">
                        <p class="text-md font-bold truncate w-full">${char.name}</p>
                        <p class="text-sm font-bold">${char.rank_points || 1000} RP</p>
                    </div>
                </div>
            `};

            if (top3.length === 0) {
                 rankingPodiumView.innerHTML = `<p class="text-center text-gray-500 col-span-full">아직 랭킹 데이터가 없습니다.</p>`;
            } else {
                rankingPodiumView.innerHTML = `
                    ${createPodiumItem(podiumData.second, 2)}
                    ${createPodiumItem(podiumData.first, 1)}
                    ${createPodiumItem(podiumData.third, 3)}
                `;
            }
        }
        
        function updatePaginationControls() {
            paginationControls.innerHTML = '';
            if (appState.allCharacters.length < appState.totalCharacterCount) {
                const loadMoreBtn = createElement('button', { id: 'load-more-btn', className: 'bg-slate-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-slate-600', textContent: '더 보기' });
                paginationControls.appendChild(loadMoreBtn);
            }
        }

        // --- NEW & FIXED RENDER FUNCTIONS ---
        window.renderAuthView = function() { /* Already handled by default HTML */ }

        window.renderDetailView = async function(charId) {
             detailViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">크리처 정보 로딩 중...</h2></div>`;
             const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email), record:battle_records(*)')
                .eq('id', charId)
                .single();
            
            if (error || !data) {
                detailViewContainer.innerHTML = `<p class="text-center p-8 text-red-400">오류: 크리처 정보를 불러올 수 없습니다.</p>`;
                console.error(error);
                return;
            }
            const char = { ...data.data, id: data.id, creator_id: data.creator_id, rank_points: data.rank_points, image_url: data.image_url, level: data.level, experience: data.experience, universe: data.universe, profile: data.profile, record: Array.isArray(data.record) && data.record.length > 0 ? data.record[0] : null };
            
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            const record = char.record || { wins: 0, losses: 0 };
            const bst = Object.values(char.stats).reduce((a, b) => a + b, 0);

            detailViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                        <div class="md:col-span-1">
                            <img src="${char.image_url}?quality=90" alt="${char.name}" class="w-full rounded-lg shadow-xl border-4 border-slate-700">
                             ${(appState.currentUser?.id === char.creator_id || appState.currentProfile?.is_admin) ? `<button id="delete-char-btn" class="w-full mt-4 bg-red-800 text-white font-bold py-2 rounded-lg hover:bg-red-700">이 크리처 삭제</button>`: ''}
                        </div>
                        <div class="md:col-span-2">
                            <h2 class="font-title text-4xl">${char.name} <span class="text-2xl text-gray-500">(${char.universe})</span></h2>
                            <div class="flex items-center gap-2 my-2">
                                <span class="rarity-badge rarity-${char.rarity}">${char.rarity}</span>
                                ${char.types.map(t => `<span class="type-badge type-${t}">${typeTranslations[t] || t}</span>`).join('')}
                            </div>
                            <p class="text-lg mt-4 text-gray-300">${char.pokedexEntry}</p>
                            <p class="text-sm text-gray-400 mt-2">소환사: <a href="#" data-profile-id="${char.creator_id}" class="text-sky-400 hover:underline">${creatorName}</a></p>

                            <div class="mt-6 p-4 bg-slate-800/50 rounded-lg">
                                <h3 class="font-bold text-xl mb-3">전투 정보</h3>
                                <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-center">
                                    <div><p class="text-gray-400 text-sm">레벨</p><p class="text-2xl font-bold">${char.level}</p></div>
                                    <div><p class="text-gray-400 text-sm">랭크 포인트</p><p class="text-2xl font-bold text-accent">${char.rank_points || 1000}</p></div>
                                    <div><p class="text-gray-400 text-sm">승리</p><p class="text-2xl font-bold text-green-400">${record.wins}</p></div>
                                    <div><p class="text-gray-400 text-sm">패배</p><p class="text-2xl font-bold text-red-400">${record.losses}</p></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div class="bg-slate-800/50 p-4 rounded-lg">
                             <h3 class="font-bold text-xl mb-3">능력치 (BST: ${bst})</h3>
                             ${Object.entries(char.stats).map(([stat, value]) => `
                                <div class="flex items-center gap-2 text-sm mb-2">
                                    <span class="w-14 font-semibold text-gray-400">${{hp:'HP', attack:'공격', defense:'방어', sp_atk:'특공', sp_def:'특방', speed:'속도'}[stat]}</span>
                                    <div class="flex-1 stat-bar-bg h-3"><div class="stat-bar h-3" style="width: ${Math.min(100, (value / (stat === 'hp' ? 300 : 150)) * 100)}%;"></div></div>
                                    <span class="w-10 text-right font-bold">${value}</span>
                                </div>
                             `).join('')}
                        </div>
                        <div class="bg-slate-800/50 p-4 rounded-lg">
                             <h3 class="font-bold text-xl mb-3">기술 및 특성</h3>
                             <div class="mb-4">
                                 <p class="font-semibold text-accent">${char.ability.name} <span class="text-sm text-gray-400">(ID: ${char.ability.id})</span></p>
                                 <p class="text-sm text-gray-300">${MASTER_ABILITY_LIST[char.ability.id]?.text || '설명 없음'}</p>
                             </div>
                             <div class="space-y-2">
                                 ${char.moves.map(move => {
                                     const masterMove = MASTER_SKILL_LIST[move.moveId] || {};
                                     return `<div class="p-2 border border-slate-700 rounded-md">
                                             <p class="font-semibold text-cyan-400">${move.name} <span class="text-xs text-gray-400">(${typeTranslations[move.type] || move.type})</span></p>
                                             <p class="text-xs text-gray-300">${move.description} (위력: ${masterMove.power || '-'})</p>
                                         </div>`
                                 }).join('')}
                             </div>
                        </div>
                    </div>
                </div>
            `;

            const deleteBtn = document.getElementById('delete-char-btn');
            if(deleteBtn) {
                deleteBtn.onclick = () => {
                    showModal(
                        '정말로 삭제하시겠습니까?',
                        `<p>${char.name} 을(를) 도감에서 영구히 삭제합니다. 이 작업은 되돌릴 수 없습니다.</p>`,
                        async () => {
                            const { error } = await supabaseClient.from('battle_characters').delete().eq('id', char.id);
                            if (error) {
                                showModal('삭제 실패', `<p>오류가 발생했습니다: ${error.message}</p>`);
                            } else {
                                showToast(`${char.name}이(가) 삭제되었습니다.`, 'success');
                                navigateTo('pokedex-view');
                            }
                        }
                    );
                };
            }
        }
        
        window.renderProfileView = async function(profileId) {
            profileViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">프로필 로딩 중...</h2></div>`;
            const { data: profile, error: profileError } = await supabaseClient.from('battle_profiles').select('*').eq('id', profileId).single();

            if (profileError || !profile) {
                profileViewContainer.innerHTML = `<p class="text-center p-8 text-red-400">프로필을 찾을 수 없습니다.</p>`;
                return;
            }

            const { data: characters, error: charsError } = await supabaseClient.from('battle_characters').select('*, record:battle_records(*)').eq('creator_id', profileId).order('created_at', { ascending: false });
            const { data: inventoryData, error: invError } = await supabaseClient.from('user_inventories').select('*, item:items(*)').eq('user_id', profileId);

            const isOwnProfile = appState.currentUser?.id === profileId;
            const nickname = profile.nickname || profile.email.split('@')[0];

            let inventoryHtml = '<p class="text-gray-500">인벤토리가 비어있습니다.</p>';
            if (inventoryData && inventoryData.length > 0) {
                inventoryHtml = inventoryData.map(inv => `
                    <div class="inventory-item p-3 rounded-lg text-center" title="${inv.item.description}">
                        <div class="inventory-item-image">${inv.item.icon || '📦'}</div>
                        <p class="font-bold text-sm">${inv.item.name}</p>
                        <p class="text-xs text-gray-400">수량: ${inv.quantity}</p>
                    </div>
                `).join('');
            }

            const today = new Date().toISOString().slice(0, 10);
            const canCheckIn = profile.last_daily_checkin !== today;

            profileViewContainer.innerHTML = `
                <div class="max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
                    <div class="bg-slate-800 p-6 rounded-lg shadow-xl mb-8">
                        <div class="flex flex-col md:flex-row items-center gap-6">
                             <div class="text-5xl">👤</div>
                            <div class="flex-1 text-center md:text-left">
                                <div class="flex items-center justify-center md:justify-start gap-3">
                                    <h2 id="profile-nickname" class="text-3xl font-bold">${nickname}</h2>
                                    ${isOwnProfile ? '<button id="edit-nickname-btn" class="text-sky-400 hover:text-sky-300 text-sm">✏️</button>' : ''}
                                </div>
                                <p class="text-gray-400">${profile.email}</p>
                                <p class="text-yellow-400 mt-2 font-semibold">크레딧: ${profile.credits}</p>
                            </div>
                            ${isOwnProfile ? `<button id="daily-checkin-btn" class="bg-green-600 text-white font-bold py-2 px-5 rounded-lg hover:bg-green-500 disabled:bg-gray-600 disabled:cursor-not-allowed">${canCheckIn ? '출석 체크 (5 크레딧)' : '오늘 출석 완료'}</button>` : ''}
                        </div>
                        ${isOwnProfile ? `
                        <div class="mt-6 pt-6 border-t border-slate-700">
                             <div class="flex items-center justify-between bg-slate-700/50 p-3 rounded-lg">
                                <div class="flex flex-col">
                                    <label for="auto-battle-toggle" class="font-semibold text-gray-300">자동 전투</label>
                                    <p class="text-xs text-gray-400">활성화 시 배틀이 자동으로 진행됩니다.</p>
                                </div>
                                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="auto-battle-toggle" id="auto-battle-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                    <label for="auto-battle-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-slate-600 cursor-pointer"></label>
                                </div>
                            </div>
                        </div>
                        `: ''}
                    </div>


                    <div class="mt-8">
                        <h3 class="font-title text-2xl mb-4">보유 크리처</h3>
                        <div id="profile-chars-container" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                            ${characters && characters.length > 0 ? characters.map(c => createCharacterCard({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, level: c.level, universe: c.universe, profile, record: Array.isArray(c.record) && c.record.length > 0 ? c.record[0] : null }).outerHTML).join('') : '<p class="text-gray-500 md:col-span-3">보유한 크리처가 없습니다.</p>'}
                        </div>
                    </div>

                    <div class="mt-8">
                        <h3 class="font-title text-2xl mb-4">인벤토리</h3>
                        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
                            ${inventoryHtml}
                        </div>
                    </div>
                </div>
            `;

            if (isOwnProfile) {
                // 출석 체크 버튼 로직
                const dailyBtn = document.getElementById('daily-checkin-btn');
                if (!canCheckIn) dailyBtn.disabled = true;

                dailyBtn.addEventListener('click', async () => {
                    if (!canCheckIn) return;
                    dailyBtn.disabled = true;
                    dailyBtn.textContent = '처리 중...';
                    const newCredits = profile.credits + 5;
                    const { error } = await supabaseClient.from('battle_profiles')
                        .update({ credits: newCredits, last_daily_checkin: today })
                        .eq('id', appState.currentUser.id);
                    
                    if (error) {
                        showToast('출석 체크 실패: ' + error.message, 'error');
                        dailyBtn.disabled = false;
                        dailyBtn.textContent = '출석 체크 (5 크레딧)';
                    } else {
                        showToast('출석 완료! 5 크레딧을 획득했습니다!', 'success');
                        appState.currentProfile.credits = newCredits;
                        appState.currentProfile.last_daily_checkin = today;
                        updateUIBasedOnAuthState();
                        dailyBtn.textContent = '오늘 출석 완료';
                    }
                });

                // 닉네임 수정 로직
                document.getElementById('edit-nickname-btn').addEventListener('click', () => {
                    const newNickname = prompt('새로운 닉네임을 입력하세요:', nickname);
                    if (newNickname && newNickname.trim() && newNickname.trim() !== nickname) {
                        const sanitizedNickname = newNickname.trim().slice(0, 20);
                        supabaseClient.from('battle_profiles').update({ nickname: sanitizedNickname }).eq('id', appState.currentUser.id).then(({error}) => {
                            if (error) {
                                showToast('닉네임 변경 실패: ' + error.message, 'error');
                            } else {
                                showToast('닉네임이 변경되었습니다.', 'success');
                                document.getElementById('profile-nickname').textContent = sanitizedNickname;
                                appState.currentProfile.nickname = sanitizedNickname;
                                updateUIBasedOnAuthState();
                            }
                        });
                    }
                });
                
                // 자동 전투 토글 로직
                const autoBattleToggle = document.getElementById('auto-battle-toggle');
                if (autoBattleToggle) {
                    autoBattleToggle.checked = profile.auto_battle_enabled;

                    autoBattleToggle.addEventListener('change', async (e) => {
                        const isEnabled = e.target.checked;
                        const { error } = await supabaseClient
                            .from('battle_profiles')
                            .update({ auto_battle_enabled: isEnabled })
                            .eq('id', appState.currentUser.id);

                        if (error) {
                            showToast('설정 저장 실패: ' + error.message, 'error');
                            e.target.checked = !isEnabled; // 실패 시 토글 원상 복구
                        } else {
                            showToast(`자동 전투가 ${isEnabled ? '활성화' : '비활성화'}되었습니다.`, 'success');
                            appState.currentProfile.auto_battle_enabled = isEnabled;
                        }
                    });
                }
            }
        }
        
        async function findOpponents() {
            if (!appState.battleSelection.selectedChar) return;

            const contentArea = document.getElementById('battle-selection-content');
            if (contentArea) {
                contentArea.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">상대를 찾는 중...</h2></div>`;
            }

            const myRank = appState.battleSelection.selectedChar.rank_points || 1000;
            const { data: opponentsData, error } = await supabaseClient
                .from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email), record:battle_records(*)')
                .not('creator_id', 'eq', appState.currentUser.id)
                .gte('rank_points', myRank - 200)
                .lte('rank_points', myRank + 200)
                .limit(10);

            if (error || !opponentsData || opponentsData.length === 0) {
                showModal('상대 찾기 실패', '<p>적절한 상대를 찾지 못했습니다. 잠시 후 다시 시도해주세요.</p>', () => {
                    renderBattleSelectionView();
                });
                return;
            }

            const opponentsList = opponentsData.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, level: c.level, universe: c.universe, profile: c.profile, record: Array.isArray(c.record) && c.record.length > 0 ? c.record[0] : null }));
            appState.battleSelection.opponentsList = opponentsList;
            
            if (contentArea) {
                contentArea.innerHTML = `
                    <p class="text-center text-gray-400 mb-8">대결할 상대를 선택하세요.</p>
                    <div id="opponent-selection-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
                `;
                
                const opponentGrid = document.getElementById('opponent-selection-grid');
                opponentsList.forEach(char => {
                    const card = createCharacterCard(char);
                    card.classList.add('border-4', 'border-transparent', 'hover:border-red-500');
                    opponentGrid.appendChild(card);
                });
            }
        }

        window.renderBattleSelectionView = async function() {
            const viewContainer = document.getElementById('battle-selection-view');
            if (!appState.currentUser) {
                navigateTo('auth-view');
                showToast('배틀을 하려면 로그인이 필요합니다.', 'error');
                return;
            }
            viewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">내 크리처 로딩 중...</h2></div>`;
            const { data, error } = await supabaseClient.from('battle_characters').select('*, record:battle_records(*)').eq('creator_id', appState.currentUser.id);

            if (error || !data) {
                viewContainer.innerHTML = `<p class="text-center p-8 text-red-400">크리처 목록을 불러올 수 없습니다.</p>`;
                return;
            }

            if (data.length === 0) {
                 viewContainer.innerHTML = `
                    <div class="text-center p-16">
                        <h2 class="text-2xl font-bold mb-4">배틀에 내보낼 크리처가 없습니다!</h2>
                        <p class="text-gray-400 mb-6">먼저 홈 화면에서 크리처를 소환해주세요.</p>
                        <button id="go-home-from-battle" class="bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-500">홈으로</button>
                    </div>`;
                document.getElementById('go-home-from-battle').onclick = () => navigateTo('pokedex-view');
                return;
            }

            const myCharacters = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, level: c.level, experience: c.experience, universe: c.universe, profile: appState.currentProfile, record: Array.isArray(c.record) && c.record.length > 0 ? c.record[0] : null }));
            
            appState.battleSelection.myCharacters = myCharacters;
            appState.battleSelection.selectedChar = null;
            appState.battleSelection.opponentsList = [];

            viewContainer.innerHTML = `
                <div class="max-w-5xl mx-auto p-4">
                    <h2 class="font-title text-4xl text-center mb-2">배틀 준비</h2>
                    <div id="battle-selection-content">
                        <p class="text-center text-gray-400 mb-8">배틀에 내보낼 나의 크리처를 선택하세요.</p>
                        <div id="my-char-selection-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        </div>
                    </div>
                </div>
            `;
            
            const grid = document.getElementById('my-char-selection-grid');
            myCharacters.forEach(char => {
                const card = createCharacterCard(char);
                card.classList.add('border-4', 'border-transparent', 'hover:border-sky-500');
                grid.appendChild(card);
            });
        }

        window.renderBattleArenaView = function(myChar, enemyChar) {
            const battleViewContainer = document.getElementById('battle-arena-view');
            const randomBg = battleBackgrounds[Math.floor(Math.random() * battleBackgrounds.length)];

            battleViewContainer.innerHTML = `
                <div class="relative w-full h-screen overflow-hidden">
                    <img id="battle-background" src="${randomBg}" class="absolute top-0 left-0 w-full h-full object-cover">
                    <div class="absolute top-0 left-0 w-full h-full bg-black/30 battle-ui-overlay">
                        <!-- Battle UI -->
                        <div class="relative w-full h-full max-w-7xl mx-auto p-4 flex flex-col">
                             <div id="damage-indicator-container" class="absolute inset-0 pointer-events-none z-20"></div>
                            <!-- Top section - Enemy -->
                            <div class="flex justify-end">
                                <div id="enemy-ui" class="battle-character-ui p-3 w-full max-w-sm relative">
                                    <div id="enemy-status-icon" class="status-icon"></div>
                                    <div class="flex justify-between items-center">
                                        <h3 id="enemy-name" class="font-bold text-lg">${enemyChar.name}</h3>
                                        <p id="enemy-level" class="text-sm font-semibold">LV.${enemyChar.level}</p>
                                    </div>
                                    <div class="hp-bar-bg rounded-full mt-1 p-0.5"><div id="enemy-hp" class="hp-bar-inner h-3 rounded-full" style="width: 100%"></div></div>
                                    <p id="enemy-hp-text" class="text-right text-xs mt-1 font-mono">${enemyChar.stats.hp} / ${enemyChar.stats.hp}</p>
                                </div>
                            </div>

                            <!-- Middle section - Sprites -->
                            <div class="flex-1 grid grid-cols-2 items-center relative">
                                <div class="flex justify-center">
                                    <img id="my-sprite" src="${myChar.image_url}" class="battle-character-sprite max-w-[200px] sm:max-w-[250px] max-h-[250px] -scale-x-100">
                                </div>
                                <div class="flex justify-center">
                                    <img id="enemy-sprite" src="${enemyChar.image_url}" class="battle-character-sprite max-w-[200px] sm:max-w-[250px] max-h-[250px]">
                                </div>
                                <div class="absolute inset-0 flex justify-center items-center pointer-events-none z-10">
                                    <span class="font-title text-6xl sm:text-8xl text-white opacity-60" style="text-shadow: 0 0 15px var(--primary);">VS</span>
                                </div>
                            </div>
                            
                            <!-- Bottom section - Player UI and Controls -->
                            <div class="flex flex-col md:flex-row gap-4 items-end">
                                <div id="my-ui" class="battle-character-ui p-3 w-full max-w-sm order-2 md:order-1 relative">
                                     <div id="my-status-icon" class="status-icon"></div>
                                    <div class="flex justify-between items-center">
                                        <h3 id="my-name" class="font-bold text-lg">${myChar.name}</h3>
                                        <p id="my-level" class="text-sm font-semibold">LV.${myChar.level}</p>
                                    </div>
                                    <div class="hp-bar-bg rounded-full mt-1 p-0.5"><div id="my-hp" class="hp-bar-inner h-3 rounded-full" style="width: 100%"></div></div>
                                    <p id="my-hp-text" class="text-right text-xs mt-1 font-mono">${myChar.stats.hp} / ${myChar.stats.hp}</p>
                                </div>
                                <div id="battle-controls" class="flex-1 grid grid-cols-2 gap-2 p-3 rounded-lg order-1 md:order-2">
                                    <!-- Moves will be injected here -->
                                </div>
                            </div>

                             <!-- Battle Log -->
                            <div id="battle-log" class="absolute bottom-1/4 left-1/2 -translate-x-1/2 bg-black/60 p-2 rounded-lg text-center text-sm w-full max-w-md backdrop-blur-sm">
                                Battle Start!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            startBattle(myChar, enemyChar);
        }

        async function startBattle(myChar, enemyChar) {
            let battleState = {
                player: myChar,
                enemy: enemyChar,
                turn: 1,
                isProcessing: false,
                log: [],
                winner: null
            };
            
            initializeFighter(battleState.player);
            initializeFighter(battleState.enemy);

            const myHpBar = document.getElementById('my-hp');
            const myHpText = document.getElementById('my-hp-text');
            const enemyHpBar = document.getElementById('enemy-hp');
            const enemyHpText = document.getElementById('enemy-hp-text');
            const mySprite = document.getElementById('my-sprite');
            const enemySprite = document.getElementById('enemy-sprite');
            const battleControls = document.getElementById('battle-controls');
            const battleLog = document.getElementById('battle-log');
            const damageContainer = document.getElementById('damage-indicator-container');
            const myStatusIcon = document.getElementById('my-status-icon');
            const enemyStatusIcon = document.getElementById('enemy-status-icon');

            function showDamageIndicator(targetSprite, damage, isCritical) {
                const indicator = document.createElement('div');
                indicator.textContent = damage;
                indicator.className = 'damage-indicator';
                if (isCritical) {
                    indicator.classList.add('critical');
                }
                
                const rect = targetSprite.getBoundingClientRect();
                const containerRect = damageContainer.getBoundingClientRect();
                
                indicator.style.left = `${rect.left - containerRect.left + rect.width / 2}px`;
                indicator.style.top = `${rect.top - containerRect.top + rect.height / 4}px`;
                
                damageContainer.appendChild(indicator);
                
                indicator.addEventListener('animationend', () => {
                    indicator.remove();
                });
            }
            
            function updateStatusIcons() {
                myStatusIcon.innerHTML = battleState.player.battleStatus.status ? `<span title="${battleState.player.battleStatus.status}">${battleState.player.battleStatus.status === 'poison' ? '☠️' : '⚡'}</span>` : '';
                enemyStatusIcon.innerHTML = battleState.enemy.battleStatus.status ? `<span title="${battleState.enemy.battleStatus.status}">${battleState.enemy.battleStatus.status === 'poison' ? '☠️' : '⚡'}</span>` : '';
            }

            function updateLog(message) {
                battleLog.textContent = message;
                battleState.log.push(`[${battleState.turn}턴] ${message}`);
            }

            function updateHpUI() {
                const myHpPercent = Math.max(0, battleState.player.battleStatus.currentHP / battleState.player.battleStatus.maxHP) * 100;
                myHpBar.style.width = `${myHpPercent}%`;
                myHpText.textContent = `${battleState.player.battleStatus.currentHP} / ${battleState.player.battleStatus.maxHP}`;

                const enemyHpPercent = Math.max(0, battleState.enemy.battleStatus.currentHP / battleState.enemy.battleStatus.maxHP) * 100;
                enemyHpBar.style.width = `${enemyHpPercent}%`;
                enemyHpText.textContent = `${battleState.enemy.battleStatus.currentHP} / ${battleState.enemy.battleStatus.maxHP}`;
            }

            function toggleControls(enable) {
                battleControls.querySelectorAll('button').forEach(btn => btn.disabled = !enable);
            }
            
            async function executeMove(attacker, defender, move, isPlayer) {
                const attackerSprite = isPlayer ? mySprite : enemySprite;
                const defenderSprite = isPlayer ? enemySprite : mySprite;
                
                const masterMove = MASTER_SKILL_LIST[move.moveId];
                updateLog(`${attacker.name}의 ${move.name}!`);
                
                attackerSprite.classList.add(isPlayer ? 'attack-lunge-anim' : 'attack-lunge-anim-enemy');
                await new Promise(r => setTimeout(r, 400));
                attackerSprite.classList.remove(isPlayer ? 'attack-lunge-anim' : 'attack-lunge-anim-enemy');
                
                if (masterMove.type === 'damage') {
                    const { damage, isCritical, effectiveness } = calculateDamage(attacker, defender, move, battleState.turn);
                    
                    if (damage > 0) {
                        defender.battleStatus.currentHP = Math.max(0, defender.battleStatus.currentHP - damage);
                        showDamageIndicator(defenderSprite, damage, isCritical);
                        playHitSound();
                        defenderSprite.classList.add('shake-anim');
                        if (isCritical) {
                            document.body.classList.add('screen-shake-crit');
                            setTimeout(() => document.body.classList.remove('screen-shake-crit'), 300);
                        }
                    }

                    updateHpUI();
                    await new Promise(r => setTimeout(r, 500));
                    
                    let effectText = `${defender.name}은(는) ${damage}의 데미지를 입었다!`;
                    if (isCritical) { effectText += ' 급소에 맞았다!'; playCritSound(); }
                    if (effectiveness > 1) { effectText += ' 효과가 굉장했다!'; playSuperEffectiveSound(); }
                    if (effectiveness < 1 && effectiveness > 0) { effectText += ' 효과가 별로인 듯하다...'; }
                    if (effectiveness === 0) { effectText += ' 효과가 없는 것 같다...'; }
                    updateLog(effectText);
                }
                
                await new Promise(r => setTimeout(r, 500));
                defenderSprite.classList.remove('shake-anim');
            }

            async function processTurn(playerMove) {
                battleState.isProcessing = true;
                toggleControls(false);

                const enemyMove = chooseSmartMove(battleState.enemy, battleState.player);
                
                const playerMasterMove = MASTER_SKILL_LIST[playerMove.moveId];
                const enemyMasterMove = MASTER_SKILL_LIST[enemyMove.moveId];
                
                let first, second, firstMove, secondMove, isPlayerFirst;
                
                if ((playerMasterMove.priority || 0) > (enemyMasterMove.priority || 0)) {
                    isPlayerFirst = true;
                } else if ((playerMasterMove.priority || 0) < (enemyMasterMove.priority || 0)) {
                    isPlayerFirst = false;
                } else {
                    isPlayerFirst = battleState.player.stats.speed >= battleState.enemy.stats.speed;
                }

                if (isPlayerFirst) {
                    [first, second, firstMove, secondMove] = [battleState.player, battleState.enemy, playerMove, enemyMove];
                } else {
                    [first, second, firstMove, secondMove] = [battleState.enemy, battleState.player, enemyMove, playerMove];
                }

                // First Mover's turn
                await executeMove(first, second, firstMove, first === battleState.player);
                if (second.battleStatus.currentHP <= 0) {
                    endBattle(first);
                    return;
                }
                await new Promise(r => setTimeout(r, 1000));

                // Second Mover's turn
                await executeMove(second, first, secondMove, second === battleState.player);
                 if (first.battleStatus.currentHP <= 0) {
                    endBattle(second);
                    return;
                }

                // End of turn
                battleState.turn++;
                battleState.isProcessing = false;
                
                if(!appState.currentProfile?.auto_battle_enabled){
                    toggleControls(true);
                    updateLog(`${myChar.name}, 무엇을 할까?`);
                } else {
                    await new Promise(r => setTimeout(r, 1000));
                    autoBattleLoop();
                }
            }
            
            async function endBattle(winner) {
                battleState.winner = winner;
                const isPlayerWinner = winner.id === battleState.player.id;
                playVictorySound();
                
                const loser = isPlayerWinner ? battleState.enemy : battleState.player;
                const { rankChange, loserRankChange, droppedItemId, leveledUp, xpGained, newLevel } = await updatePostBattleStats(winner, loser);

                let itemDropText = '';
                if (droppedItemId) {
                    const item = appState.allItems.find(i => i.id === droppedItemId);
                    if (item) itemDropText = `<p class="mt-2 text-sm text-yellow-300">아이템 <strong>[${item.name}]</strong>을(를) 획득했다!</p>`;
                }
                
                let levelUpText = '';
                if(isPlayerWinner && leveledUp) {
                    levelUpText = `<p class="text-sm text-cyan-400 mt-2">레벨 업! LV.${newLevel-1} ➔ LV.${newLevel}</p>`;
                }
                const xpText = isPlayerWinner ? `<p class="text-sm text-gray-400">+${xpGained} XP</p>` : '';

                const modalContent = `
                    <div class="text-center">
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <!-- Winner Column -->
                            <div class="flex flex-col items-center p-4 bg-slate-700/50 rounded-lg border-2 border-yellow-400">
                                <img src="${winner.image_url}?width=200" class="w-24 h-24 object-cover rounded-full border-4 border-yellow-400 mb-2" alt="${winner.name}">
                                <p class="font-bold text-lg text-yellow-300">${winner.name}</p>
                                <p id="winner-rp-change" class="font-bold text-xl text-green-400">+0 RP</p>
                                ${isPlayerWinner ? xpText : ''}
                                ${levelUpText}
                            </div>
                            <!-- Loser Column -->
                            <div class="flex flex-col items-center p-4 bg-slate-800/50 rounded-lg">
                                <img src="${loser.image_url}?width=200" class="w-24 h-24 object-cover rounded-full border-4 border-slate-600 mb-2" alt="${loser.name}">
                                <p class="font-bold text-lg">${loser.name}</p>
                                <p id="loser-rp-change" class="font-bold text-xl text-red-400">0 RP</p>
                            </div>
                        </div>
                        ${itemDropText}
                        <div class="mt-6 flex justify-center gap-3">
                            <button id="rematch-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-500">재대결</button>
                            <button id="view-log-btn" class="bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500">로그 기록</button>
                            <button id="main-menu-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-500">메인 화면</button>
                        </div>
                    </div>
                `;
                
                showModal(isPlayerWinner ? "승리!" : "패배...", modalContent, null, { closeOnOverlayClick: false });

                const winnerRpElement = document.getElementById('winner-rp-change');
                const loserRpElement = document.getElementById('loser-rp-change');

                anime({ targets: winnerRpElement, innerHTML: [0, rankChange], round: 1, easing: 'easeOutExpo', duration: 1500, update: (anim) => { winnerRpElement.innerHTML = `+${anim.animations[0].currentValue} RP` } });
                anime({ targets: loserRpElement, innerHTML: [0, loserRankChange], round: 1, easing: 'easeOutExpo', duration: 1500, update: (anim) => { loserRpElement.innerHTML = `${anim.animations[0].currentValue} RP` } });

                document.getElementById('rematch-btn').onclick = () => {
                    closeModal();
                    navigateTo('battle-arena-view', battleState.player, battleState.enemy);
                };
                document.getElementById('view-log-btn').onclick = () => {
                    showBattleLogModal(battleState.log);
                };
                document.getElementById('main-menu-btn').onclick = () => {
                    closeModal();
                    navigateTo('pokedex-view');
                };
            }
            
            async function autoBattleLoop() {
                while (!battleState.winner) {
                    const playerMove = chooseSmartMove(battleState.player, battleState.enemy);
                    await processTurn(playerMove);
                }
            }
            
            // --- BATTLE START ---
            updateLog(`${myChar.name}, 무엇을 할까?`);

            if (appState.currentProfile?.auto_battle_enabled) {
                battleControls.innerHTML = '<p class="text-center col-span-2 text-sky-400">자동 전투 진행 중...</p>';
                updateLog('자동 전투가 활성화되었습니다. 전투를 시작합니다...');
                await new Promise(r => setTimeout(r, 2000));
                autoBattleLoop();
            } else {
                myChar.moves.forEach((move, index) => {
                    const btn = createElement('button', { className: 'battle-move-item p-3 rounded-lg border text-left', 'data-move-index': index });
                    btn.innerHTML = `
                        <p class="font-bold text-sm sm:text-base">${move.name}</p>
                        <p class="text-xs text-gray-400">${typeTranslations[move.type] || move.type}</p>
                    `;
                    btn.onclick = () => {
                        if (battleState.isProcessing || battleState.winner) return;
                        processTurn(move);
                    };
                    battleControls.appendChild(btn);
                });
            }
        }

        window.renderManualView = function() {
            manualViewContainer.innerHTML = `
            <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8 bg-slate-800 rounded-lg shadow-xl mt-8">
                <h2 class="font-title text-4xl text-center mb-8 text-cyan-400">게임 방법</h2>
                <div id="manual-content">
                    <h3>📜 기본 규칙</h3>
                    <p>몬배틀 헌터즈는 자신만의 독특한 크리처를 생성하여 다른 유저의 크리처와 대결하고 랭킹을 올리는 게임입니다.</p>
                    <ol class="list-decimal list-inside space-y-2 mb-4">
                        <li><strong>크리처 소환</strong>: 메인 화면에서 원하는 종족과 컨셉을 입력하여 새로운 크리처를 소환할 수 있습니다. (1 크레딧 소모)</li>
                        <li><strong>배틀 아레나</strong>: 소환한 크리처로 다른 크리처와 1:1 배틀을 진행합니다. 승리하면 랭크 포인트(RP)와 경험치(XP)를 얻습니다.</li>
                        <li><strong>성장</strong>: 크리처는 전투에서 승리하여 얻는 XP로 레벨업을 할 수 있습니다. 레벨이 오르면 능력치가 강해집니다.</li>
                    </ol>
                    <h3>✨ 특별 보너스 시스템</h3>
                    <p>전투를 더욱 흥미진진하게 만드는 특별한 보너스 시스템이 존재합니다.</p>
                    <h4>👑 언더독 보너스</h4>
                    <p>자신보다 훨씬 강한 상대를 이겼을 때 주어지는 특별 보상입니다.</p>
                     <ul class="list-disc list-inside space-y-1 mb-4">
                        <li>자신보다 <strong>5레벨 이상 높은 상대</strong>에게 승리하면, 획득하는 <strong>경험치(XP)가 2배</strong>가 되고 <strong>랭크 포인트(RP)도 대폭 상승</strong>합니다.</li>
                    </ul>
                    <h3>🎁 아이템 시스템</h3>
                    <p>전투에서 승리하면 일정 확률로 특별한 아이템을 획득할 수 있습니다. 획득한 아이템은 마이페이지의 '인벤토리'에서 확인할 수 있습니다.</p>
                    <ul class="list-disc list-inside space-y-1 mb-4">
                        <li><strong>획득 방법</strong>: 전투 승리 시 약 25%의 확률로 아이템을 얻습니다.</li>
                        <li><strong>아이템 종류</strong>: 레벨업을 돕는 소모품부터 크리처를 강화하는 희귀한 아이템까지 다양하게 존재합니다.</li>
                    </ul>
                </div>
            </div>`;
        }
        
        window.renderAdminView = function() {
            const adminViewContainer = document.getElementById('admin-view');
            if (!appState.currentProfile?.is_admin) {
                adminViewContainer.innerHTML = `<div class="max-w-4xl mx-auto p-8 text-center"><h2 class="text-2xl text-red-500">접근 권한이 없습니다.</h2></div>`;
                return;
            }
            adminViewContainer.innerHTML = `<div class="max-w-4xl mx-auto p-8"><h2 class="text-3xl font-bold text-center">관리자 페이지</h2><p class="text-center mt-4">이곳에서 아이템 지급, 유저 관리 등의 기능을 추가할 수 있습니다.</p></div>`;
        }

        window.renderRankingView = async function() {
            const rankingViewContainer = document.getElementById('ranking-view');
            rankingViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">랭킹 로딩 중...</h2></div>`;
            const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email), record:battle_records(*)')
                .order('rank_points', { ascending: false, nullsFirst: false })
                .limit(100);

            if (error) {
                rankingViewContainer.innerHTML = `<p class="text-center p-8 text-red-400">랭킹을 불러오는 데 실패했습니다: ${error.message}</p>`;
                return;
            }
            const sorted = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile, record: Array.isArray(c.record) && c.record.length > 0 ? c.record[0] : null, universe: c.universe, level: c.level }));
            
            const listHtml = sorted.map((char, index) => {
                const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
                const record = char.record || { wins: 0, losses: 0 };
                return `
                <div class="flex items-center gap-4 p-3 bg-slate-800/50 rounded-lg hover:bg-slate-700/50 cursor-pointer" data-char-id="${char.id}">
                    <div class="w-10 text-center text-xl font-bold text-gray-400">${index + 1}</div>
                    <img src="${char.image_url}?width=128&quality=80" alt="${char.name}" class="w-16 h-16 rounded-md object-cover">
                    <div class="flex-1">
                        <p class="font-bold text-lg">${char.name} <span class="text-sm text-gray-500">(LV.${char.level})</span></p>
                        <p class="text-sm text-gray-400">소환사: <a href="#" data-profile-id="${char.creator_id}" class="text-sky-400 hover:underline">${creatorName}</a></p>
                    </div>
                    <div class="text-right">
                         <p class="font-bold text-lg text-accent">${char.rank_points || 1000} RP</p>
                         <p class="text-sm text-gray-400">${record.wins}승 / ${record.losses}패</p>
                    </div>
                </div>
                `
            }).join('');

            rankingViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <h2 class="font-title text-4xl text-center mb-8">전체 랭킹</h2>
                    <div class="space-y-2">${listHtml}</div>
                </div>
            `;
        };

        // --- MAIN APP INITIALIZATION ---
        function initApp() {
            document.addEventListener('DOMContentLoaded', async () => {
                const { data: { session } } = await supabaseClient.auth.getSession();
                appState.currentUser = session?.user || null;
                await initialDataLoad();
                listenToAuthStateChanges();
                subscribeToChanges();
                document.body.addEventListener('click', setupAudio, { once: true });
            });

            homeBtn.addEventListener('click', () => navigateTo('pokedex-view'));
            generateBtn.addEventListener('click', generateCharacter);
            promptInput.addEventListener('keydown', e => e.key === 'Enter' && generateCharacter());
            goToBattleBtn.addEventListener('click', () => navigateTo('battle-selection-view'));
            goToRankingBtn.addEventListener('click', () => navigateTo('ranking-view'));
            showManualBtn.addEventListener('click', () => navigateTo('manual-view'));
            showRarityTableBtn.addEventListener('click', showRarityModal);
            
            const showTypeChartBtn = document.getElementById('show-type-chart-btn');
            if (showTypeChartBtn) {
                showTypeChartBtn.addEventListener('click', showTypeChartModal);
            }

            loginForm.addEventListener('submit', handleLogin);
            signupForm.addEventListener('submit', handleSignup);
            
            const togglePasswordBtn = document.getElementById('toggle-password-visibility');
            const loginPasswordInput = document.getElementById('login-password');
            const eyeIcon = document.getElementById('eye-icon');
            const eyeSlashIcon = document.getElementById('eye-slash-icon');

            togglePasswordBtn.addEventListener('click', () => {
                const isPassword = loginPasswordInput.type === 'password';
                loginPasswordInput.type = isPassword ? 'text' : 'password';
                eyeIcon.classList.toggle('hidden', isPassword);
                eyeSlashIcon.classList.toggle('hidden', !isPassword);
            });

            document.getElementById('forgot-password-link').addEventListener('click', (e) => {
                e.preventDefault();
                showModal('비밀번호 재설정', `<p>가입하신 이메일 주소를 입력하시면, 비밀번호를 재설정할 수 있는 링크를 보내드립니다.</p><form id="reset-password-form" class="mt-4 flex gap-2"><input type="email" id="reset-email-input" class="flex-1 p-2 border rounded-lg bg-slate-700 text-white border-slate-600" placeholder="이메일" required><button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">전송</button></form>`);
                document.getElementById('reset-password-form').onsubmit = async (ev) => {
                    ev.preventDefault();
                    const email = document.getElementById('reset-email-input').value;
                    const { error } = await supabaseClient.auth.resetPasswordForEmail(email, { redirectTo: window.location.origin });
                    if (error) { showModal('오류', `<p>비밀번호 재설정 메일 전송에 실패했습니다: ${error.message}</p>`); } 
                    else { showModal('메일 전송 완료', `<p><strong>${email}</strong>(으)로 비밀번호 재설정 메일을 보냈습니다. 이메일을 확인해주세요.</p>`); }
                };
            });
            
            document.body.addEventListener('click', (e) => {
                const profileLink = e.target.closest('[data-profile-id]');
                if (profileLink) {
                    e.preventDefault();
                    e.stopPropagation();
                    navigateTo('profile-view', profileLink.dataset.profileId);
                    return;
                }

                const card = e.target.closest('[data-char-id]');
                if (card) {
                    const activeView = card.closest('.view');
                    if (!activeView) return;
                    playUiClickSound();

                    switch (activeView.id) {
                        case 'battle-selection-view':
                            if (card.parentElement.id === 'my-char-selection-grid') {
                                const charId = parseInt(card.dataset.charId);
                                appState.battleSelection.selectedChar = appState.battleSelection.myCharacters.find(c => c.id === charId);
                                if (appState.battleSelection.selectedChar) {
                                    findOpponents(); 
                                }
                            }
                            else if (card.parentElement.id === 'opponent-selection-grid') {
                                const opponentId = parseInt(card.dataset.charId);
                                const selectedOpponent = appState.battleSelection.opponentsList.find(o => o.id === opponentId);
                                if (appState.battleSelection.selectedChar && selectedOpponent) {
                                    navigateTo('battle-arena-view', appState.battleSelection.selectedChar, selectedOpponent);
                                }
                            }
                            break;
                        case 'pokedex-view':
                        case 'ranking-view':
                        case 'profile-view':
                             navigateTo('detail-view', card.dataset.charId);
                            break;
                    }
                    return;
                }

                if (e.target.id === 'load-more-btn') {
                    loadMoreCharacters();
                }
            });


            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    playUiClickSound();
                    const tab = btn.dataset.tab;
                    document.querySelectorAll('.auth-form').forEach(form => form.classList.add('hidden'));
                    document.getElementById(`${tab}-form`).classList.remove('hidden');
                    tabBtns.forEach(b => b.classList.remove('border-sky-500', 'text-sky-400'));
                    btn.classList.add('border-sky-500', 'text-sky-400');
                });
            });
            if(tabBtns.length > 0) tabBtns[0].click();
            
            filterBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    playUiClickSound();
                    filterBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    appState.activeFilter = btn.dataset.filter;
                    appState.allCharacters = [];
                    appState.currentPage = 0;
                    pokedexContainer.innerHTML = ''; 
                    loadMoreCharacters();
                });
            });
        }
        
        initApp();
    </script>
</body>
</html>

